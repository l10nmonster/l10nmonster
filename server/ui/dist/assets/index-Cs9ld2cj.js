import{r as c,m as J,W as B,X,Y,Z,_ as w,$ as V,a0 as G,a1 as b,a2 as D,a3 as H,a4 as K,a5 as Q}from"./index-Dj9K5Hqe.js";function tt(t,n){return`${t} returned \`undefined\`. Seems you forgot to wrap component within ${n}`}function A(t={}){const{name:n,strict:r=!0,hookName:o="useContext",providerName:u="Provider",errorMessage:i,defaultValue:d}=t,f=c.createContext(d);f.displayName=n;function g(){const v=c.useContext(f);if(!v&&r){const y=new Error(i??tt(o,u));throw y.name="ContextError",Error.captureStackTrace?.(y,g),y}return v}return[f.Provider,g,f]}const[at,it]=A({name:"EnvironmentContext",hookName:"useEnvironmentContext",providerName:"<EnvironmentProvider />",strict:!1,defaultValue:{getRootNode:()=>document,getDocument:()=>document,getWindow:()=>window}});function et(...t){return n=>{const r=[];for(const o of t)if(typeof o=="function"){const u=o(n);typeof u=="function"&&r.push(u)}else o&&(o.current=n);if(r.length)return()=>{for(const o of r)o()}}}function nt(t){let n=Object.getOwnPropertyDescriptor(t.props,"ref")?.get,r=n&&"isReactWarning"in n&&n.isReactWarning;return r?t.ref:(n=Object.getOwnPropertyDescriptor(t,"ref")?.get,r=n&&"isReactWarning"in n&&n.isReactWarning,r?t.props.ref:t.props.ref||t.ref)}const j=t=>{const n=c.memo(c.forwardRef((r,o)=>{const{asChild:u,children:i,...d}=r;if(!u)return c.createElement(t,{...d,ref:o},i);if(!c.isValidElement(i))return null;const f=c.Children.only(i),g=nt(f);return c.cloneElement(f,{...J(d,f.props),ref:o?et(o,g):g})}));return n.displayName=t.displayName||t.name,n},rt=()=>{const t=new Map;return new Proxy(j,{apply(n,r,o){return j(o[0])},get(n,r){const o=r;return t.has(o)||t.set(o,j(o)),t.get(o)}})},ft=rt(),[lt,dt]=A({name:"LocaleContext",hookName:"useLocaleContext",providerName:"<LocaleProvider />",strict:!1,defaultValue:{dir:"ltr",locale:"en-US"}}),gt=()=>(t,n)=>n.reduce((r,o)=>{const[u,i]=r,d=o;return i[d]!==void 0&&(u[d]=i[d]),delete i[d],[u,i]},[{},{...t}]);var L=B(),F=typeof globalThis.document<"u"?c.useLayoutEffect:c.useEffect;function k(t){const n=t().value??t().defaultValue,r=t().isEqual??Object.is,[o]=c.useState(n),[u,i]=c.useState(o),d=t().value!==void 0,f=c.useRef(u);f.current=d?t().value:u;const g=c.useRef(f.current);F(()=>{g.current=f.current},[u,t().value]);const v=p=>{const m=g.current,E=b(p)?p(m):p;t().debug&&console.log(`[bindable > ${t().debug}] setValue`,{next:E,prev:m}),d||i(E),r(E,m)||t().onChange?.(E,m)};function y(){return d?t().value:u}return{initial:o,ref:f,get:y,set(p){(t().sync?L.flushSync:G)(()=>v(p))},invoke(p,m){t().onChange?.(p,m)},hash(p){return t().hash?.(p)??String(p)}}}k.cleanup=t=>{c.useEffect(()=>t,[])};k.ref=t=>{const n=c.useRef(t);return{get:()=>n.current,set:r=>{n.current=r}}};function ot(t){const n=c.useRef(t);return{get(r){return n.current[r]},set(r,o){n.current[r]=o}}}var st=(t,n)=>{const r=c.useRef(!1),o=c.useRef(!1);c.useEffect(()=>{if(r.current&&o.current)return n();o.current=!0},[...(t??[]).map(u=>typeof u=="function"?u():u)]),c.useEffect(()=>(r.current=!0,()=>{r.current=!1}),[])};function pt(t,n={}){const r=c.useMemo(()=>{const{id:e,ids:s,getRootNode:l}=n;return X({id:e,ids:s,getRootNode:l})},[n]),o=(...e)=>{t.debug&&console.log(...e)},u=t.props?.({props:Y(n),scope:r})??n,i=ct(u),d=t.context?.({prop:i,bindable:k,scope:r,flush:_,getContext(){return g},getComputed(){return P},getRefs(){return M},getEvent(){return E()}}),f=U(d),g={get(e){return f.current?.[e].ref.current},set(e,s){f.current?.[e].set(s)},initial(e){return f.current?.[e].initial},hash(e){const s=f.current?.[e].get();return f.current?.[e].hash(s)}},v=c.useRef(new Map),y=c.useRef(null),p=c.useRef(null),m=c.useRef({type:""}),E=()=>({...m.current,current(){return m.current},previous(){return p.current}}),$=()=>({...x,matches(...e){return e.includes(x.ref.current)},hasTag(e){return!!t.states[x.ref.current]?.tags?.includes(e)}}),M=ot(t.refs?.({prop:i,context:g})??{}),h=()=>({state:$(),context:g,event:E(),prop:i,send:z,action:S,guard:q,track:st,refs:M,computed:P,flush:_,scope:r,choose:T}),S=e=>{const s=b(e)?e(h()):e;if(!s)return;const l=s.map(a=>{const R=t.implementations?.actions?.[a];return R||D(`[zag-js] No implementation found for action "${JSON.stringify(a)}"`),R});for(const a of l)a?.(h())},q=e=>b(e)?e(h()):t.implementations?.guards?.[e](h()),O=e=>{const s=b(e)?e(h()):e;if(!s)return;const l=s.map(R=>{const C=t.implementations?.effects?.[R];return C||D(`[zag-js] No implementation found for effect "${JSON.stringify(R)}"`),C}),a=[];for(const R of l){const C=R?.(h());C&&a.push(C)}return()=>a.forEach(R=>R?.())},T=e=>H(e).find(s=>{let l=!s.guard;return K(s.guard)?l=!!q(s.guard):b(s.guard)&&(l=s.guard(h())),l}),P=e=>{Z(t.computed,()=>"[zag-js] No computed object found on machine");const s=t.computed[e];return s({context:g,event:E(),prop:i,refs:M,scope:r,computed:P})},x=k(()=>({defaultValue:t.initialState({prop:i}),onChange(e,s){s&&(v.current.get(s)?.(),v.current.delete(s)),s&&S(t.states[s]?.exit),S(y.current?.actions);const l=O(t.states[e]?.effects);if(l&&v.current.set(e,l),s===V){S(t.entry);const a=O(t.effects);a&&v.current.set(V,a)}S(t.states[e]?.entry)}})),W=c.useRef(void 0),N=c.useRef(w.NotStarted);F(()=>{queueMicrotask(()=>{const l=N.current===w.Started;N.current=w.Started,o(l?"rehydrating...":"initializing...");const a=W.current??x.initial;x.invoke(a,l?x.get():V)});const e=v.current,s=x.ref.current;return()=>{o("unmounting..."),W.current=s,N.current=w.Stopped,e.forEach(l=>l?.()),v.current=new Map,y.current=null,queueMicrotask(()=>{S(t.exit)})}},[]);const I=()=>"ref"in x?x.ref.current:x.get(),z=e=>{queueMicrotask(()=>{if(N.current!==w.Started)return;p.current=m.current,m.current=e;let s=I();const l=t.states[s].on?.[e.type]??t.on?.[e.type],a=T(l);if(!a)return;y.current=a;const R=a.target??s;o("transition",e.type,a.target||s,`(${a.actions})`);const C=R!==s;C?L.flushSync(()=>x.set(R)):a.reenter&&!C?x.invoke(s,s):S(a.actions??[])})};return t.watch?.(h()),{state:$(),send:z,context:g,prop:i,scope:r,refs:M,computed:P,event:E(),getStatus:()=>N.current}}function U(t){const n=c.useRef(t);return n.current=t,n}function ct(t){const n=U(t);return function(o){return n.current[o]}}function _(t){queueMicrotask(()=>{L.flushSync(()=>t())})}var mt=Q(t=>t);export{ft as a,dt as b,A as c,pt as d,gt as e,et as f,mt as n,it as u};
