/**
 * @typedef {import('./types.js').ConfigMancerSchema} ConfigMancerSchema
 * @typedef {import('./types.js').SchemaEntry} SchemaEntry
 */

/**
 * CueSchemaGenerator generates CUE schema definitions from ConfigMancer schemas.
 * It supports polymorphism through disjunctions and properly handles the `@` type marker.
 */
export class CueSchemaGenerator {
    #schema;
    #superTypeIndex;

    /**
     * Creates a new CueSchemaGenerator instance.
     * @param {ConfigMancerSchema} schema - The ConfigMancer schema to generate CUE from
     */
    constructor(schema) {
        this.#schema = schema;
        this.#superTypeIndex = this.#buildSuperTypeIndex();
    }

    /**
     * Builds an index mapping superTypes to their concrete implementations.
     * This enables generating disjunctions for polymorphic properties.
     * @returns {Map<string, string[]>} Map of superType to array of concrete type names
     */
    #buildSuperTypeIndex() {
        const index = new Map();

        for (const [typeName, def] of Object.entries(this.#schema)) {
            const { superType } = def;

            // Skip if this is a root type (superType === typeName)
            if (superType === typeName) continue;

            // Skip primitive types (they don't need indexing)
            if (['string', 'number', 'boolean'].includes(superType)) continue;

            // Add to index (includes 'object' and custom supertypes like 'GHPolicy')
            if (!index.has(superType)) {
                index.set(superType, []);
            }
            index.get(superType).push(typeName);
        }

        return index;
    }

    /**
     * Generates a complete CUE schema.
     * If rootType is provided, generates only that type and its dependencies.
     * If rootType is omitted, generates all types in the schema.
     * @param {string} [rootType] - Optional root type to generate schema for
     * @param {string} [packageName] - Optional package name for the CUE file
     * @returns {string} Complete CUE schema as a string
     * @throws {Error} If the specified root type is not found in the schema
     */
    generateCueSchema(rootType, packageName) {
        const definitions = [];

        if (rootType) {
            // Generate specific type and its dependencies
            if (!this.#schema[rootType]) {
                throw new Error(`Root type "${rootType}" not found in schema`);
            }
            const visited = new Set();
            this.#collectTypes(rootType, definitions, visited);

            // Add abstract supertypes that have implementations but no explicit definition
            this.#addAbstractSupertypes(definitions, visited);
        } else {
            // Add abstract supertypes first (those with implementations but no explicit definition)
            this.#addAllAbstractSupertypes(definitions);

            // Generate all types in alphabetical order (no dependency recursion needed)
            for (const typeName of Object.keys(this.#schema).sort()) {
                const def = this.#schema[typeName];
                if (def) {
                    definitions.push(this.#generateTypeDef(typeName, def));
                }
            }
        }

        const schemaContent = definitions.join('\n\n');

        // Build the final output with optional package and header comment
        const headerComment = '// Code generated by ConfigMancer. DO NOT EDIT.\n';

        if (packageName) {
            return `${headerComment}\npackage ${packageName}\n\n${schemaContent}`;
        }

        return `${headerComment}\n${schemaContent}`;
    }

    /**
     * Adds abstract supertype definitions for types that have implementations but no explicit definition.
     * This handles the case where multiple types share a superType (interface-like behavior).
     * @param {string[]} definitions - Array to accumulate CUE definitions
     * @param {Set<string>} visited - Set of already visited types (used to determine which supertypes to include)
     */
    #addAbstractSupertypes(definitions, visited) {
        for (const [superType, implementations] of this.#superTypeIndex.entries()) {
            // Skip if this supertype has an explicit definition in the schema
            if (this.#schema[superType]) continue;

            // Only include if at least one implementation was visited
            const hasVisitedImpl = implementations.some(impl => visited.has(impl));
            if (!hasVisitedImpl) continue;

            // Generate disjunction of all implementations that were visited
            const visitedImpls = implementations.filter(impl => visited.has(impl)).sort();
            const disjunction = visitedImpls.map(t => `#${this.#sanitizeTypeName(t)}`).join(' | ');

            // Special case: 'object' supertype should also allow any arbitrary object
            const finalDisjunction = superType === 'object'
                ? `${disjunction} | {...}`
                : disjunction;

            const sanitizedSuperType = this.#sanitizeTypeName(superType);
            definitions.unshift(`// Abstract supertype: ${superType}\n#${sanitizedSuperType}: ${finalDisjunction}`);
        }
    }

    /**
     * Adds all abstract supertype definitions for the entire schema.
     * @param {string[]} definitions - Array to accumulate CUE definitions
     */
    #addAllAbstractSupertypes(definitions) {
        for (const [superType, implementations] of this.#superTypeIndex.entries()) {
            // Skip if this supertype has an explicit definition in the schema
            if (this.#schema[superType]) continue;

            // Generate disjunction of all implementations
            const disjunction = implementations.sort().map(t => `#${this.#sanitizeTypeName(t)}`).join(' | ');

            // Special case: 'object' supertype should also allow any arbitrary object
            const finalDisjunction = superType === 'object'
                ? `${disjunction} | {...}`
                : disjunction;

            const sanitizedSuperType = this.#sanitizeTypeName(superType);
            definitions.push(`// Abstract supertype: ${superType}\n#${sanitizedSuperType}: ${finalDisjunction}`);
        }
    }

    /**
     * Recursively collects all types needed for a complete schema.
     * @param {string} typeName - The type to collect
     * @param {string[]} definitions - Array to accumulate CUE definitions
     * @param {Set<string>} visited - Set of already visited types
     */
    #collectTypes(typeName, definitions, visited) {
        if (visited.has(typeName)) return;

        // Skip primitive types
        if (['string', 'number', 'boolean', 'object'].includes(typeName)) return;

        const def = this.#schema[typeName];
        if (!def) return;

        visited.add(typeName);

        // Collect dependencies first (depth-first)
        for (const [paramType] of Object.values(def.params)) {
            // If this paramType has implementations, collect all of them
            const implementations = this.#superTypeIndex.get(paramType);
            if (implementations) {
                for (const implType of implementations) {
                    this.#collectTypes(implType, definitions, visited);
                }
            } else {
                this.#collectTypes(paramType, definitions, visited);
            }
        }

        // Generate definition for this type
        definitions.push(this.#generateTypeDef(typeName, def));
    }

    /**
     * Sanitizes a type name to be a valid CUE identifier.
     * Replaces special characters like @, /, : with underscores.
     * @param {string} typeName - The original type name
     * @returns {string} A valid CUE identifier
     */
    #sanitizeTypeName(typeName) {
        // Replace special characters with underscores
        // CUE identifiers can only contain letters, digits, underscores, and dollar signs
        return typeName.replace(/[@/:.-]/g, '_');
    }

    /**
     * Generates a CUE type definition for a single type.
     * @param {string} typeName - The name of the type
     * @param {SchemaEntry} def - The schema entry for the type
     * @returns {string} CUE definition string
     */
    #generateTypeDef(typeName, def) {
        const sanitizedName = this.#sanitizeTypeName(typeName);

        if (def.isConstant) {
            return this.#generateConstant(sanitizedName, def);
        }

        let cue = `#${sanitizedName}: {\n`;
        cue += `\t"@": "${typeName}"\n`;

        // Sort parameters for consistent output
        const sortedParams = Object.entries(def.params).sort(([a], [b]) => a.localeCompare(b));

        for (const [paramName, [paramType, isMandatory, isArray]] of sortedParams) {
            const fieldName = isMandatory ? `${paramName}!` : `${paramName}?`;
            const fieldType = this.#generatePropertyType(paramType, isArray);
            cue += `\t${fieldName}: ${fieldType}\n`;
        }

        cue += '}';
        return cue;
    }

    /**
     * Generates a CUE constant definition.
     * @param {string} typeName - The name of the constant
     * @param {SchemaEntry} def - The schema entry for the constant
     * @returns {string} CUE constant definition
     */
    #generateConstant(typeName, def) {
        const cueValue = JSON.stringify(def.factory);
        return `#${typeName}: ${cueValue}`;
    }

    /**
     * Generates the CUE type expression for a property.
     * Handles polymorphism by referencing abstract supertypes when they exist.
     * @param {string} paramType - The parameter type from the schema
     * @param {boolean} isArray - Whether this is an array type
     * @returns {string} CUE type expression
     */
    #generatePropertyType(paramType, isArray) {
        const implementations = this.#superTypeIndex.get(paramType);
        let typeExpr;

        if (implementations && implementations.length > 0) {
            // If there's an abstract supertype (not explicitly defined in schema), reference it
            // This avoids duplicating the disjunction inline
            if (!this.#schema[paramType]) {
                typeExpr = `#${this.#sanitizeTypeName(paramType)}`;
            } else {
                // Supertype is explicitly defined, so generate disjunction
                typeExpr = implementations.sort().map(t => `#${this.#sanitizeTypeName(t)}`).join(' | ');
            }
        } else {
            // Primitive or single type
            typeExpr = this.#mapToCueType(paramType);
        }

        return isArray ? `[...${typeExpr}]` : typeExpr;
    }

    /**
     * Maps ConfigMancer types to CUE types.
     * @param {string} type - The ConfigMancer type
     * @returns {string} The corresponding CUE type
     */
    #mapToCueType(type) {
        const mapping = {
            string: 'string',
            number: 'number',
            boolean: 'bool',
            object: '{...}', // Open struct
        };

        return mapping[type] || `#${this.#sanitizeTypeName(type)}`;
    }

}
