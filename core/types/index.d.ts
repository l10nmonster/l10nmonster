// Generated by dts-bundle-generator v9.5.1

/// <reference types="node" />

/**
 * @typedef {import('../../index.js').NormalizedString} NormalizedString
 * @typedef {import('../../index.js').StructuredNotes} StructuredNotes
 * @typedef {import('../../index.js').JobProps} JobProps
 */
/**
 * Represents a Translation Unit (TU).
 */
export class TU {
	/**
	 * Creates a TU instance with only the source string.
	 * @param {Partial<TU>} obj - The object to convert to a source TU.
	 * @returns {TU} The created source TU.
	 */
	static asSource(obj: Partial<TU>): TU;
	/**
	 * Creates a TU instance with both source and target strings.
	 * @param {Partial<TU>} obj - The object to convert to a target TU.
	 * @returns {TU} The created target TU.
	 */
	static asTarget(obj: Partial<TU>): TU;
	/**
	 * Creates a TU instance with both source and target strings.
	 * @param {Partial<TU>} obj - The object to convert to a pair TU.
	 * @returns {TU} The created pair TU.
	 */
	static asPair(obj: Partial<TU>): TU;
	/**
	 * Converts a segment into a source TU.
	 * @param {{ id: string, prj?: string }} res - The resource object containing the segment.
	 * @param {import('../../index.js').NormalizedSegment} segment - The segment to convert.
	 * @returns {TU} The created source TU.
	 */
	static fromSegment(res: {
		id: string;
		prj?: string;
	}, segment: NormalizedSegment$5): TU;
	/**
	 * Creates a pair TU from request and response objects.
	 * @param {Partial<TU>} [req] - The request TU object.
	 * @param {Partial<TU>} [res] - The response TU object.
	 * @param {Partial<TU>} [additionalProps] - Additional properties to merge.
	 * @returns {TU} The created pair TU.
	 */
	static fromRequestResponse(req?: Partial<TU>, res?: Partial<TU>, additionalProps?: Partial<TU>): TU;
	/**
	 * Creates a new TU instance.
	 * @param {Partial<TU>} entry - A TU-like object with properties like guid, rid, sid, nsrc, etc.
	 * @param {boolean} isSource - Indicates if the TU is a source.
	 * @param {boolean} isTarget - Indicates if the TU is a target.
	 * @throws Will throw an error if the required properties are missing based on the TU type.
	 */
	constructor(entry: Partial<TU>, isSource: boolean, isTarget: boolean);
	/** @type {string} Resource ID the TU belongs to. */
	rid: string;
	/** @type {string} Segment ID the TU belongs to. */
	sid: string;
	/** @type {NormalizedString | undefined} Normalized source string for the TU. */
	nsrc: NormalizedString | undefined;
	/** @type {string} Unique identifier for the TU. */
	guid: string;
	/** @type {boolean | undefined} Indicates if the TU is in-flight (submitted and pending translation). */
	inflight: boolean | undefined;
	/** @type {NormalizedString | undefined} Normalized target string for the TU. */
	ntgt: NormalizedString | undefined;
	/** @type {number | undefined} Timestamp for the TU. */
	ts: number | undefined;
	/** @type {number | undefined} Quality score for the TU. */
	q: number | undefined;
	/** @type {string | StructuredNotes | undefined} Structured notes for translators. */
	notes: string | StructuredNotes | undefined;
	/** @type {string | undefined} Project name for filtering. */
	prj: string | undefined;
	/** @type {string | undefined} Plural form (one, other, zero, two, few, many). */
	pluralForm: string | undefined;
	/** @type {string | undefined} Opaque native ID in original storage format. */
	nid: string | undefined;
	/** @type {number | undefined} Sequence number to shorten GUID. */
	seq: number | undefined;
	/** @type {JobProps | undefined} Job-specific properties. */
	jobProps: JobProps | undefined;
	/** @type {number | number[] | undefined} Translation cost (number or array for detailed token breakdown). */
	cost: number | number[] | undefined;
	/** @type {string | undefined} Job GUID this TU was translated in. */
	jobGuid: string | undefined;
	/** @type {string | undefined} ID of the translation provider. */
	translationProvider: string | undefined;
	/** @type {number | undefined} Translation confidence score. */
	tconf: number | undefined;
	/** @type {string | undefined} Translation notes. */
	tnotes: string | undefined;
	/** @type {object | undefined} QA data. */
	qa: object | undefined;
	/** @type {string | undefined} Translation hash for detecting vendor-side fixes. */
	th: string | undefined;
	/** @type {{ reviewedWords?: number, errorsFound?: number } | undefined} Review data (reviewed words and errors found). */
	rev: {
		reviewedWords?: number;
		errorsFound?: number;
	} | undefined;
}
type NormalizedString = NormalizedString$7;
type StructuredNotes = StructuredNotes$3;
type JobProps = JobProps$3;
interface PlaceholderPart {
	/** The type of the placeholder (e.g., 'x' for generic, 'ph' for ICU). */
	t: string;
	/** The original value/code of the placeholder. */
	v: string;
	/** A simplified/normalized version of the placeholder for matching. */
	v1?: string;
	/** Sample/example content for the placeholder. */
	s?: string;
	/** Flag set by decoder to identify which decoder processed this part. */
	flag?: string;
}
type Part = string | PlaceholderPart;
type NormalizedString$1 = Part[];
interface StructuredNotes$1 {
	/** Clean description text. */
	desc?: string;
	/** Maximum width constraint. */
	maxWidth?: number;
	/** Screenshot reference. */
	screenshot?: string;
	/** Array of tags. */
	tags?: string[];
	/** Placeholder descriptions. */
	ph?: Record<string, {
		sample: string;
		desc?: string;
	}>;
}
interface Segment {
	/** The segment ID (unique within the resource). */
	sid: string;
	/** The translatable string (raw, unnormalized). */
	str: string;
	/** Optional notes associated with the segment for translators. */
	notes?: string;
	/** If the segment is pluralized, this is the form of the plural. */
	pluralForm?: string;
	/** Opaque native ID of the segment in the original storage format. */
	nid?: string;
	/** Message format identifier (e.g., 'icu', 'mf2'). */
	mf?: string;
}
interface NormalizedSegment {
	/** Segment ID. */
	sid: string;
	/** Unique identifier for the segment (rid + sid + hash). */
	guid: string;
	/** Normalized string (array of parts). */
	nstr: NormalizedString$1;
	/** Notes for translators (raw string or structured). */
	notes?: string | StructuredNotes$1;
	/** Raw notes before processing. */
	rawNotes?: string;
	/** Plural form if applicable. */
	pluralForm?: string;
	/** Message format identifier (e.g., 'icu', 'mf2'). */
	mf?: string;
	/** Native ID in original format. */
	nid?: string;
	/** Flags set during normalization. */
	flags?: string[];
	/** Translation plan per target language. */
	plan?: Record<string, unknown>;
	/** Project identifier (inherited from resource). */
	prj?: string;
	/** Sequence number for compact GUID representation. */
	seq?: number;
}
interface ResourceHeader {
	/** Resource identifier (typically file path or unique key). */
	id: string;
	/** Source language code (e.g., 'en-US'). */
	sourceLang: string;
	/** Target language codes for this resource. */
	targetLangs?: string[];
	/** Project name for filtering and organization. */
	prj?: string;
	/** Override the default format handler for this resource. */
	resourceFormat?: string;
	/** Last modified timestamp. */
	modified?: string | number;
}
interface ResourceHandle {
	/** Resource identifier (typically file path or unique key). */
	id: string;
	/** Channel ID this resource belongs to. */
	channel: string;
	/** Last modified timestamp. */
	modified?: string | number;
	/** Format handler ID. */
	resourceFormat: string;
	/** Source language code. */
	sourceLang: string;
	/** Target language codes for this resource. */
	targetLangs: string[];
	/** Translation plan per target language. */
	plan?: TranslationPlan;
	/** Project name for filtering. */
	prj?: string;
	/** Raw resource content. */
	raw?: string;
	/** Parsed normalized segments. */
	segments?: NormalizedSegment[];
	/** Nested subresources. */
	subresources?: Subresource[];
	// Methods
	/** Loads segments and subresources from a normalized resource. */
	loadFromNormalizedResource(normalizedResource: {
		segments: NormalizedSegment[];
		subresources?: Subresource[];
	}): ResourceHandle;
	/** Loads and normalizes a resource from raw content. */
	loadResourceFromRaw(rawResource: string, options: {
		isSource?: boolean;
	}): Promise<ResourceHandle>;
	/** Generates translated raw resource content from the current segments and TM. */
	generateTranslatedRawResource(tm: TMInterface): Promise<string | null>;
	/** Applies translation policies to all segments. */
	applyPolicies(translationPolicyPipeline: TranslationPolicy[]): Promise<void>;
}
interface Channel {
	/** Get information about this channel's configuration. */
	getInfo(): {
		id: string;
		source: string;
		target: string;
		formatHandlers: unknown[];
		defaultResourceFormat: string;
		translationPolicies: number;
	};
	/** Creates a ResourceHandle from a resource header. */
	makeResourceHandleFromHeader(resourceHeader: ResourceHeader): ResourceHandle;
	/** Fetches all resources from the source, normalizes them, and applies translation policies. */
	getAllNormalizedResources(options?: Record<string, unknown>): AsyncGenerator<ResourceHandle>;
	/** Fetches an existing translated resource. */
	getExistingTranslatedResource(resHandle: ResourceHandle, targetLang: string): Promise<ResourceHandle>;
	/** Commits a translated resource to the target. */
	commitTranslatedResource(targetLang: string, resourceId: string, rawResource: string | null): Promise<string>;
}
interface ChannelOptions {
	/** Base directory for relative paths. */
	baseDir?: string;
}
interface SourceAdapter {
	/**
	 * Fetches all resources as [header, rawContent] tuples.
	 * @param options - Optional filtering/configuration options.
	 * @returns AsyncGenerator yielding [ResourceHeader, string] tuples.
	 */
	fetchAllResources(options?: object): AsyncGenerator<[
		ResourceHeader,
		string
	]>;
	/**
	 * Optional method to receive channel configuration.
	 * @param options - Channel configuration options.
	 */
	setChannelOptions?(options: ChannelOptions): void;
}
interface TargetAdapter {
	/**
	 * Returns the target resource ID given target language and source resource ID.
	 * @param targetLang - The target language code.
	 * @param sourceResourceId - The source resource identifier.
	 * @returns The target resource identifier.
	 */
	translatedResourceId(targetLang: string, sourceResourceId: string): string;
	/**
	 * Fetches existing translation given target language and resource ID.
	 * @param targetLang - The target language code.
	 * @param resourceId - The resource identifier.
	 * @returns The translated content, or null if not found.
	 */
	fetchTranslatedResource(targetLang: string, resourceId: string): Promise<string | null>;
	/**
	 * Commits translated content to the target system.
	 * @param targetLang - The target language code.
	 * @param resourceId - The resource identifier.
	 * @param rawContent - The translated raw content (null to delete).
	 */
	commitTranslatedResource(targetLang: string, resourceId: string, rawContent: string | null): Promise<void>;
	/**
	 * Optional method to receive channel configuration.
	 * @param options - Channel configuration options.
	 */
	setChannelOptions?(options: ChannelOptions): void;
}
interface TMStoreBlock {
	/** Full path/name of the block file. */
	blockName: string;
	/** Last modified timestamp string. */
	modified: string;
	/** Array of [jobGuid, updatedAt] tuples for jobs in this block. */
	jobs: Array<[
		string,
		string
	]>;
}
interface TMStoreTOC {
	/** Version number. */
	v: number;
	/** Source language code. */
	sourceLang: string;
	/** Target language code. */
	targetLang: string;
	/** Map of block IDs to block metadata. */
	blocks: Record<string, TMStoreBlock>;
	/** Array of [blockId, fileName] tuples for blocks in storage. */
	storedBlocks: Array<[
		string,
		string
	]>;
}
interface JobPropsTusPair {
	/** Job properties (metadata). */
	jobProps: JobProps$1;
	/** Translation units in the job. */
	tus: TU$1[];
}
interface TMStore {
	/** The logical id of this store instance. */
	id: string;
	/** The store access permissions. */
	access: "readwrite" | "readonly" | "writeonly";
	/** The partitioning strategy for TM blocks. */
	partitioning: "job" | "provider" | "language";
	/**
	 * Gets available language pairs in the store.
	 * @returns Array of [sourceLang, targetLang] tuples.
	 */
	getAvailableLangPairs?(): Promise<Array<[
		string,
		string
	]>>;
	/**
	 * Gets the table of contents for a language pair.
	 * @param sourceLang - Source language code.
	 * @param targetLang - Target language code.
	 * @returns TOC object with block metadata.
	 */
	getTOC?(sourceLang: string, targetLang: string): Promise<TMStoreTOC>;
	/**
	 * Gets TM blocks by their IDs.
	 * @param sourceLang - Source language code.
	 * @param targetLang - Target language code.
	 * @param blockIds - Array of block IDs to retrieve.
	 * @returns AsyncGenerator yielding job objects with TUs.
	 */
	getTmBlocks?(sourceLang: string, targetLang: string, blockIds: string[]): AsyncGenerator<JobPropsTusPair>;
	/**
	 * Gets a writer for committing TM data.
	 * @param sourceLang - Source language code.
	 * @param targetLang - Target language code.
	 * @param cb - Callback function for writing blocks.
	 */
	getWriter?(sourceLang: string, targetLang: string, cb: Function): Promise<void>;
}
interface SnapStore {
	/** The logical id of this store instance. */
	id: string;
	/**
	 * Gets the table of contents listing all snapshots.
	 * @returns Object mapping channel IDs to arrays of timestamps.
	 */
	getTOC?(): Promise<Record<string, number[]>>;
	/**
	 * Generates rows from a snapshot.
	 * @param ts - Snapshot timestamp.
	 * @param channelId - Channel identifier.
	 * @param table - Table name ('segments' or 'resources').
	 * @returns AsyncGenerator yielding row objects.
	 */
	generateRows?(ts: number, channelId: string, table: string): AsyncGenerator<Record<string, unknown>>;
	/**
	 * Saves a snapshot from a row generator.
	 * @param ts - Snapshot timestamp.
	 * @param channelId - Channel identifier.
	 * @param rowGenerator - AsyncGenerator providing rows to save.
	 * @param table - Table name ('segments' or 'resources').
	 * @returns Stats object with count of saved rows.
	 */
	saveSnap?(ts: number, channelId: string, rowGenerator: AsyncGenerator<Record<string, unknown>>, table: string): Promise<{
		count: number;
	}>;
}
interface Subresource {
	/** Format handler identifier for this subresource. */
	resourceFormat: string;
	/** Raw content of the subresource. */
	raw: string;
	/** Resource identifier (added after generation). */
	id?: string;
	/** GUIDs of segments in this subresource (added after parsing). */
	guids?: string[];
}
interface ResourceFilter {
	/**
	 * Parses raw resource content into segments.
	 * @param params - Parse parameters including resource content.
	 * @returns Object with segments array and optional subresources.
	 */
	parseResource(params: {
		resource: string;
		isSource?: boolean;
		sourcePluralForms?: string[];
		targetPluralForms?: string[];
	}): Promise<{
		segments: Segment[];
		subresources?: Subresource[];
	}>;
	/**
	 * Translates a resource using a translator function.
	 * @param params - Translation parameters.
	 * @returns Translated resource content.
	 */
	translateResource?(params: {
		resource: string;
		translator: (sid: string, str: string) => Promise<string | undefined>;
		sourcePluralForms?: string[];
		targetPluralForms?: string[];
	}): Promise<string | undefined>;
}
interface GenerateResourceParams {
	/** Resource identifier. */
	id: string;
	/** Channel identifier. */
	channel?: string;
	/** Source language code. */
	sourceLang: string;
	/** Target language codes. */
	targetLangs?: string[];
	/** Project identifier. */
	prj?: string;
	/** Raw resource content. */
	raw?: string;
	/** Parsed segments. */
	segments?: NormalizedSegment[];
	/** Nested subresources. */
	subresources?: Subresource[];
	/** Format handler identifier. */
	resourceFormat?: string;
	/** Translation plan. */
	plan?: Record<string, number>;
	/** Translator function to get translations for segments (generator style). */
	translator: (seg: NormalizedSegment) => Promise<{
		nstr: NormalizedString$1;
		str: string;
		tu: TU$1;
	} | undefined>;
	/** Source plural forms. */
	sourcePluralForms?: string[];
	/** Target plural forms. */
	targetPluralForms?: string[];
}
interface ResourceGenerator {
	/**
	 * Generates raw content from translated segments.
	 * @param params - Generation parameters.
	 * @returns Generated raw content.
	 */
	generateResource(params: GenerateResourceParams): string | Promise<string | undefined>;
}
interface JobProps$1 {
	/** Unique job identifier. */
	jobGuid: string;
	/** Source language code. */
	sourceLang: string;
	/** Target language code. */
	targetLang: string;
	/** Job status. */
	status?: "created" | "pending" | "done" | "cancelled" | "blocked";
	/** Human-readable status description. */
	statusDescription?: string;
	/** Provider ID that will handle this job. */
	translationProvider?: string;
	/** Estimated cost for translation. */
	estimatedCost?: number;
	/** Translation instructions for the provider. */
	instructions?: string;
	/** Translation group for routing to specific providers. */
	group?: string;
	/** Minimum quality required for TUs in this job. */
	minQ?: number;
	/** Name of the async task (for resumable jobs). */
	taskName?: string;
	/** Human-readable job name. */
	jobName?: string;
	/** ISO timestamp when job was created. */
	createdAt?: string;
	/** ISO timestamp when job was last updated. */
	updatedAt?: string;
}
interface TU$1 {
	/** Unique identifier for the TU (hash of rid+sid+source). */
	guid: string;
	/** Resource ID the TU belongs to. */
	rid?: string;
	/** Segment ID within the resource. */
	sid?: string;
	/** Normalized source string. */
	nsrc?: NormalizedString$1;
	/** Normalized target string (translation). */
	ntgt?: NormalizedString$1;
	/** Quality score of the translation (0-100). */
	q?: number;
	/** Timestamp when the translation was created (epoch ms). */
	ts?: number;
	/** Minimum quality required for this TU. */
	minQ?: number;
	/** Word count for the source text. */
	words?: number;
	/** Character count for the source text. */
	chars?: number;
	/** Project identifier. */
	prj?: string;
	/** Translation group for routing to specific providers. */
	group?: string;
	/** Plural form (one, other, zero, two, few, many). */
	pluralForm?: string;
	/** Opaque native ID in original storage format. */
	nid?: string;
	/** Sequence number to shorten GUID. */
	seq?: number;
	/** Whether the TU is currently in-flight (submitted, pending translation). */
	inflight?: boolean;
	/** Translation confidence score. */
	tconf?: number;
	/** Translation notes from provider. */
	tnotes?: string;
	/** Job GUID this TU was translated in. */
	jobGuid?: string;
	/** ID of the translation provider. */
	translationProvider?: string;
	/** Notes for translators (raw string or structured). */
	notes?: string | StructuredNotes$1;
	/** Translation cost (number or array for detailed token breakdown). */
	cost?: number | number[];
	/** QA data from quality checks. */
	qa?: Record<string, unknown>;
	/** Translation hash for detecting vendor-side fixes. */
	th?: string;
	/** Review data (reviewed words and errors found). */
	rev?: {
		reviewedWords?: number;
		errorsFound?: number;
	};
	/** Job-specific properties (used for TM export/import). */
	jobProps?: JobProps$1;
	/** Channel ID (used by grandfather provider). */
	channel?: string;
}
interface Job extends JobProps$1 {
	/** Translation units in the job. */
	tus?: TU$1[];
	/** GUIDs of TUs that are in-flight. */
	inflight?: string[];
}
interface JobRequest {
	/** Source language code. */
	sourceLang: string;
	/** Target language code. */
	targetLang: string;
	/** Translation units to process. */
	tus: (TU$1 | NormalizedSegment)[];
	/** Optional job GUID (assigned by dispatcher). */
	jobGuid?: string;
	/** Translation instructions. */
	instructions?: string;
	/** Translation group. */
	group?: string;
}
type TranslationPlan = Record<string, number>;
interface PolicyContext {
	/** Translation plan being built (maps target lang to requirements). */
	plan: TranslationPlan;
	/** The segment being processed. */
	seg: NormalizedSegment;
	/** The resource handle containing the segment. */
	res: ResourceHandle;
	/** Additional properties can be added by policies. */
	[key: string]: unknown;
}
type TranslationPolicy = (policyContext: PolicyContext) => Partial<PolicyContext> | PolicyContext;
interface EncodeFlags {
	/** Source language code. */
	sourceLang?: string;
	/** Target language code. */
	targetLang?: string;
	/** Project identifier. */
	prj?: string;
	/** True if encoding the first part. */
	isFirst?: boolean;
	/** True if encoding the last part. */
	isLast?: boolean;
	/** Allow additional custom flags. */
	[key: string]: string | boolean | undefined;
}
type DecoderFunction = (parts: Part[]) => Part[];
type TextEncoderFunction = (text: string, flags?: EncodeFlags) => string;
type CodeEncoderFunction = (part: PlaceholderPart | string, flags?: EncodeFlags) => string;
type PartTransformer = (parts: Part[]) => Part[];
interface ProviderStatusProperty {
	/** Actions that can trigger this status. */
	actions: string[];
	/** Human-readable description of this status. */
	description: string;
}
interface ActionHelp {
	/** Action description shown in help. */
	description: string;
	/** Short summary for list view. */
	summary?: string;
	/** Array of [flag, description, choices?] tuples for options. */
	options?: Array<[
		string,
		string,
		string[]?
	]>;
	/** Array of [flag, description] tuples for required options. */
	requiredOptions?: Array<[
		string,
		string
	]>;
	/** Array of [name, description, choices?] tuples for arguments. */
	arguments?: Array<[
		string,
		string,
		string[]?
	]>;
}
interface L10nAction {
	/** Action name (command name). */
	name: string;
	/** Help configuration for this action. */
	help: ActionHelp;
	/** Sub-actions for grouped commands. */
	subActions?: L10nAction[];
	/**
	 * Execute the action.
	 * @param mm - MonsterManager instance.
	 * @param options - Command options and arguments.
	 * @returns Action result.
	 */
	action?(mm: MonsterManager, options: Record<string, unknown>): Promise<unknown>;
}
type L10nActionClass = L10nAction;
interface TranslationProvider {
	/** Provider identifier (readonly). */
	readonly id: string;
	/** Quality score assigned to translations from this provider. */
	quality?: number;
	/** Status property definitions for UI/reporting. */
	statusProperties: Record<string, ProviderStatusProperty>;
	/**
	 * Initialize provider with MonsterManager.
	 * @param mm - MonsterManager instance.
	 */
	init?(mm: MonsterManager): Promise<void>;
	/**
	 * Create a job from a job request.
	 * @param job - Job request to process.
	 * @param options - Optional creation options.
	 * @returns Created job with status and metadata.
	 */
	create(job: JobRequest | Job, options?: {
		skipQualityCheck?: boolean;
		skipGroupCheck?: boolean;
	}): Promise<Job>;
	/**
	 * Start a created job (execute translation).
	 * @param job - Job to start.
	 * @returns Job with updated status and translations.
	 */
	start(job: Job): Promise<Job>;
	/**
	 * Continue a pending job (for async providers).
	 * @param job - Job to continue.
	 * @returns Job with updated status.
	 */
	continue(job: Job): Promise<Job>;
	/**
	 * Get provider information.
	 * @returns Provider metadata and capabilities.
	 */
	info(): Promise<{
		id: string;
		type: string;
		quality?: number;
		supportedPairs?: Record<string, string[]>;
		costPerWord?: number;
		costPerMChar?: number;
		description: string[];
	}>;
}
interface StatusProperty {
	/** Available actions for this status (e.g., 'start', 'continue'). */
	actions: string[];
	/** Human-readable description of this status. */
	description: string;
}
interface StatusProperties {
	created: StatusProperty;
	pending: StatusProperty;
	done: StatusProperty;
	cancelled: StatusProperty;
	[key: string]: StatusProperty;
}
interface XmlTu {
	/** Bundle/resource identifier. */
	bundle: string;
	/** Key/segment identifier. */
	key: string;
	/** Source text in XML format with placeholders. */
	source: string;
	/** Optional notes for translators. */
	notes?: string;
	/** Optional existing translation. */
	translation?: string;
}
interface TranslateChunkArgs {
	/** Source language code (potentially mapped). */
	sourceLang: string;
	/** Target language code (potentially mapped). */
	targetLang: string;
	/** Translation units in XML format. */
	xmlTus: XmlTu[];
	/** Job GUID for tracking. */
	jobGuid: string;
	/** Optional translation instructions. */
	instructions?: string;
	/** Chunk number for logging. */
	chunkNumber: number;
}
interface ProviderTranslateChunkArgs extends TranslateChunkArgs {
}
interface ProviderResponseChunk {
}
interface TranslatedChunk {
	/** Target translation text. */
	tgt: string;
	/** Optional cost information (number or array for detailed token breakdown). */
	cost?: number | number[];
	/** TU index in the chunk (used by LLM provider). */
	tuIdx?: number;
	/** GUID of the TU (added during processing). */
	guid?: string;
	/** Normalized target string (added during processing). */
	ntgt?: NormalizedString$1;
}
interface ChunkTuMeta {
	/** GUID of the translation unit. */
	guid: string;
	/** Placeholder map for reconstructing normalized strings. */
	phMap?: Record<string, PlaceholderPart>;
}
interface TranslateChunkOpResult {
	/** Raw response from the provider (for debugging). */
	raw: ProviderResponseChunk;
	/** Normalized translation results. */
	res: Array<{
		guid: string;
		ntgt: NormalizedString$1;
		cost?: number | number[];
	}>;
}
interface AnalysisResult {
	/** Column headers for the analysis output. */
	head: string[];
	/** Optional columns to group results by. */
	groupBy?: string[];
	/** Row data for the analysis. */
	body: unknown[][];
}
interface AnalyzerTU {
	/** Unique identifier for the translation unit. */
	guid: string;
	/** Normalized source string. */
	nsrc: NormalizedString$1;
	/** Normalized target string (translation). */
	ntgt: NormalizedString$1;
	/** Resource ID the TU belongs to. */
	rid?: string;
	/** String ID within the resource. */
	sid?: string;
}
interface Analyzer {
	/**
	 * Process a segment during analysis.
	 * @param context - Segment context containing rid, prj, and seg.
	 */
	processSegment?(context: {
		rid: string;
		prj: string;
		seg: NormalizedSegment;
	}): void;
	/**
	 * Process a translation unit during analysis.
	 * @param context - TU context containing targetLang and tu.
	 */
	processTU?(context: {
		targetLang: string;
		tu: AnalyzerTU;
	}): void;
	/**
	 * Get the analysis results.
	 * @returns Analysis result with headers and data rows.
	 */
	getAnalysis?(): AnalysisResult;
	/**
	 * Get aggregate analysis results (for multi-language analyzers).
	 * @returns Aggregate analysis result.
	 */
	getAggregateAnalysis?(): AnalysisResult;
}
interface AnalyzerClass {
	/** Static help description for the analyzer. */
	help?: string;
	/** Static help parameters for the analyzer. */
	helpParams?: string;
	/** Creates an instance of the analyzer. */
	new (...args: unknown[]): Analyzer;
	/** Prototype for checking method availability. */
	prototype: Analyzer;
}
interface ResourceManagerInterface {
	/** Array of active channel IDs. */
	readonly channelIds: string[];
	/** Array of snap store IDs. */
	readonly snapStoreIds: string[];
	/** Get desired language pairs for a channel. */
	getDesiredLangPairs(channelId: string): Promise<Array<[
		string,
		string
	]>>;
	/** Get desired target languages for a channel. */
	getDesiredTargetLangs(channelId: string, limitToLang?: string | string[]): Promise<string[]>;
	/** Get channel metadata. */
	getChannelMeta(channelId: string): Promise<ChannelTocRow | undefined>;
	/** Get a channel by ID. */
	getChannel(channelId: string): Channel;
	/** Get active content statistics for a channel. */
	getActiveContentStats(channelId: string): Promise<Array<{
		prj: string;
		sourceLang: string;
		segmentCount: number;
		resCount: number;
		targetLangs: string[];
		lastModified?: number;
	}>>;
	/** Get all resources for a channel. */
	getAllResources(channelId: string, options?: Record<string, unknown>): AsyncGenerator<ResourceHandle>;
	/** Get a resource handle by ID. */
	getResourceHandle(channelId: string, rid: string, options?: {
		keepRaw?: boolean;
	}): Promise<ResourceHandle | undefined>;
	/** Get snap store TOC. */
	getSnapStoreTOC(snapStoreId: string): Promise<Record<string, number[]>>;
	/** Create a snapshot of a channel. */
	snap(channelId: string): Promise<{
		resources: number;
		segments: number;
	}>;
	/** Import from a snapshot. */
	import(ts: number, channelId: string, snapStoreId: string): Promise<void>;
	/** Export content from channels to a snap store. */
	export(channelId: string, snapStoreId: string): Promise<{
		ts?: number;
		resources?: {
			count: number;
		};
		segments?: {
			count: number;
		};
	}>;
}
interface TMManagerInterface {
	/** Array of TM store IDs. */
	readonly tmStoreIds: string[];
	/** Get a TM instance for a language pair. */
	getTM(sourceLang: string, targetLang: string): TMInterface;
	/** Get a TM store by ID. */
	getTmStore(id: string): TMStore | undefined;
	/** Get TM store TOCs. */
	getTmStoreTOCs(tmStore: TMStore, parallelism?: number): Promise<Array<[
		string,
		string,
		TMStoreTOC
	]>>;
	/** Get available language pairs from the TM. */
	getAvailableLangPairs(): Promise<Array<[
		string,
		string
	]>>;
	/** Get TM statistics. */
	getStats(): Promise<Array<{
		sourceLang: string;
		targetLang: string;
		tuCount: number;
		jobCount: number;
	}>>;
	/** Get job TOC by language pair. */
	getJobTOCByLangPair(sourceLang: string | null, targetLang: string | null): Promise<Array<{
		jobGuid: string;
		status: string;
		translationProvider: string;
		updatedAt: string;
	}>>;
	/** Get a job by GUID. */
	getJob(jobGuid: string): Promise<JobProps$1 | undefined>;
	/** Delete a job. */
	deleteJob(jobGuid: string): Promise<void>;
	/** Sync down from a TM store. */
	syncDown(tmStore: TMStore, options: Record<string, unknown>): Promise<Array<{
		sourceLang: string;
		targetLang: string;
		blocksToStore: string[];
		jobsToDelete: string[];
	}>>;
	/** Sync up to a TM store. */
	syncUp(tmStore: TMStore, options: Record<string, unknown>): Promise<Array<{
		sourceLang: string;
		targetLang: string;
		blocksToUpdate: [
			string,
			string[]
		][];
		jobsToUpdate: string[];
	}>>;
	/** Bootstrap the TM database from a TM store (DESTRUCTIVE). */
	bootstrap(tmStore: TMStore, options?: {
		dryrun?: boolean;
		sourceLang?: string;
		targetLang?: string;
		parallelism?: number;
	}): Promise<{
		pairs: Array<[
			string,
			string
		]>;
		stats?: Array<{
			sourceLang: string;
			targetLang: string;
			jobCount: number;
			tuCount: number;
		}>;
		dryrun: boolean;
	}>;
}
interface TMInterface {
	/** Source language code. */
	readonly sourceLang: string;
	/** Target language code. */
	readonly targetLang: string;
	/** Get TU entries by GUIDs. */
	getEntries(guids: string[]): Promise<Record<string, TU$1>>;
	/** Get exact matches for a normalized source string. */
	getExactMatches(nsrc: NormalizedString$1): Promise<TU$1[]>;
	/** Get translation status for translated content in a channel. */
	getTranslatedContentStatus(channelId: string): Promise<Record<string, Array<{
		minQ: number;
		q: number;
		seg: number;
		words: number;
		chars: number;
	}>>>;
	/** Get translation status for untranslated content in a channel. */
	getUntranslatedContentStatus(channelId: string): Promise<Record<string, Record<string, Array<{
		seg: number;
		words: number;
		chars: number;
	}>>>>;
	/** Get untranslated content for a channel. */
	getUntranslatedContent(channelId: string, options?: {
		limit?: number;
		prj?: string | string[];
	}): Promise<NormalizedSegment[]>;
	/** Query source content with filters. */
	querySource(channelId: string, whereCondition: string): Promise<NormalizedSegment[]>;
	/** Search TUs with filtering and pagination. */
	search(offset: number, limit: number, params?: TuSearchParams): Promise<TU$1[]>;
	/** Get TM statistics. */
	getStats(): Promise<Array<{
		translationProvider: string;
		status: string;
		tuCount: number;
		distinctGuids: number;
		jobCount: number;
	}>>;
	/** Get quality distribution. */
	getQualityDistribution(): Promise<Array<{
		q: number;
		count: number;
	}>>;
	/** Get TU keys over a certain rank. */
	tuKeysOverRank(maxRank: number): Promise<Array<[
		string,
		string
	]>>;
	/** Get TU keys by quality. */
	tuKeysByQuality(quality: number): Promise<Array<[
		string,
		string
	]>>;
	/** Delete TUs by their keys. */
	deleteTuKeys(tuKeys: Array<[
		string,
		string
	]>): Promise<{
		deletedTusCount: number;
		touchedJobsCount: number;
	}>;
	/** Delete empty jobs. */
	deleteEmptyJobs(dryrun?: boolean): Promise<number>;
	/** Bootstrap this language pair with bulk data from a job iterator. */
	bootstrap(jobIterator: AsyncIterable<JobPropsTusPair>, tmStoreId: string): Promise<{
		jobCount: number;
		tuCount: number;
	}>;
}
interface DispatcherInterface {
	/** Array of registered providers. */
	readonly providers: TranslationProvider[];
	/** Get provider by ID. */
	getProvider(providerId: string): TranslationProvider | undefined;
	/** Get all providers. */
	getProviders(): TranslationProvider[];
	/** Create jobs from a job request. */
	createJobs(job: JobRequest, options?: Record<string, unknown>): Promise<Job[]>;
	/** Start created jobs. */
	startJobs(jobs: Job[], options?: Record<string, unknown>): Promise<Array<{
		sourceLang: string;
		targetLang: string;
		jobGuid: string;
		translationProvider: string;
		status: string;
		statusDescription?: string;
	}>>;
	/** Update a pending job. */
	updateJob(jobGuid: string): Promise<Job | undefined>;
}
interface MonsterManager {
	/** Resource manager for source content operations. */
	readonly rm: ResourceManagerInterface;
	/** Translation memory manager. */
	readonly tmm: TMManagerInterface;
	/** Translation provider dispatcher. */
	readonly dispatcher: DispatcherInterface;
	/** Whether to save failed jobs. */
	saveFailedJobs: boolean;
	/** Registered action handlers. */
	readonly l10n: Record<string, (opts?: Record<string, unknown>) => Promise<unknown>>;
	/** Registered analyzers. */
	readonly analyzers: Record<string, AnalyzerClass>;
	/** Currency formatter for cost display. */
	readonly currencyFormatter: Intl.NumberFormat;
	/**
	 * Initialize the MonsterManager.
	 */
	init(): Promise<void>;
	/**
	 * Schedule a function to be called during shutdown.
	 * @param func - Async cleanup function.
	 */
	scheduleForShutdown(func: () => Promise<void>): void;
	/**
	 * Run an analyzer on source content or translation memory.
	 * @param analyzer - Analyzer name or class.
	 * @param params - Parameters for the analyzer.
	 * @param limitToLang - Optional language to limit analysis.
	 * @returns Analysis results.
	 */
	analyze(analyzer: string | Analyzer, params?: string[], limitToLang?: string): Promise<AnalysisResult>;
	/**
	 * Get translation status for channels.
	 * @param channels - Channel ID(s) or undefined for all.
	 * @returns Translation status by channel/source/target/project.
	 */
	getTranslationStatus(channels?: string | string[]): Promise<Record<string, Record<string, Record<string, Record<string, unknown>>>>>;
	/**
	 * Shutdown the MonsterManager and run cleanup functions.
	 */
	shutdown(): Promise<void>;
}
interface SerializedOp {
	/** Operation name. */
	opName: string;
	/** Operation ID. */
	opId: number;
	/** Operation arguments. */
	args: Record<string, unknown>;
	/** IDs of input dependencies. */
	inputOpIds: (number | undefined)[];
	/** Operation state ('pending', 'done', 'error', or custom). */
	state: string;
	/** Operation output. */
	output: unknown;
	/** Last execution timestamp (ISO string). */
	lastRanAt?: string;
}
interface OpsStoreInterface {
	/**
	 * Save operations for a task.
	 * @param taskName - Name/ID of the task.
	 * @param opList - List of serialized operations to save.
	 */
	saveOps(taskName: string, opList: SerializedOp[]): Promise<void>;
	/**
	 * Get operations for a task.
	 * @param taskName - Name/ID of the task.
	 * @returns Async generator of serialized operation objects.
	 */
	getTask(taskName: string): AsyncGenerator<SerializedOp>;
}
type SegmentDecorator = (seg: Segment) => Segment | undefined;
interface SegmentDecoratorFactory {
	/**
	 * Initialize the factory with MonsterManager.
	 * @param mm - MonsterManager instance.
	 */
	init?(mm: MonsterManager): Promise<void>;
	/**
	 * Get the decorator function.
	 * @returns Segment decorator function.
	 */
	getDecorator(): SegmentDecorator;
}
interface FileStoreDelegate {
	/**
	 * Ensures the base directory exists.
	 * @returns The created directory path or undefined.
	 */
	ensureBaseDirExists(): Promise<string | undefined>;
	/**
	 * Lists all files in the store.
	 * @returns Array of [filename, metadata] tuples.
	 */
	listAllFiles(): Promise<Array<[
		string,
		string
	]>>;
	/**
	 * Gets a readable stream for a file.
	 * @param filename - File path.
	 * @returns Readable stream (may be sync or async depending on implementation).
	 */
	getStream(filename: string): NodeJS.ReadableStream | Promise<NodeJS.ReadableStream>;
	/**
	 * Gets file contents as string.
	 * @param filename - File path.
	 * @returns File contents.
	 */
	getFile(filename: string): Promise<string>;
	/**
	 * Saves string contents to a file.
	 * @param filename - File path or path segments.
	 * @param contents - File contents.
	 * @returns Modified timestamp or path.
	 */
	saveFile(filename: string | string[], contents: string): Promise<string>;
	/**
	 * Saves a stream to a file.
	 * @param filename - File path or path segments.
	 * @param readable - Readable stream.
	 * @param deleteEmptyFiles - Whether to delete if stream is empty.
	 * @returns Modified timestamp, path, or null if deleted.
	 */
	saveStream(filename: string | string[], readable: NodeJS.ReadableStream, deleteEmptyFiles?: boolean): Promise<string | null>;
	/**
	 * Deletes multiple files.
	 * @param filenames - Array of file paths to delete.
	 */
	deleteFiles(filenames: string[]): Promise<void>;
	/**
	 * String representation of the delegate.
	 */
	toString(): string;
}
interface ChannelMeta {
	/** Timestamp for the snapshot. */
	ts: number;
	/** Optional external snap store ID. */
	snapStoreId?: string;
	/** Optional store identifier (derived from snapStoreId in implementation). */
	store?: string;
}
interface ChannelTocRow {
	/** Channel identifier. */
	channel: string;
	/** Store identifier. */
	store?: string;
	/** Timestamp of the snapshot. */
	ts?: number;
	/** Number of resources in the channel. */
	resources?: number;
	/** Number of segments in the channel. */
	segments?: number;
}
interface TuSearchParams {
	/** Filter by GUID (supports SQL LIKE patterns). */
	guid?: string;
	/** Filter by NID (supports SQL LIKE patterns). */
	nid?: string;
	/** Filter by job GUID (supports SQL LIKE patterns). */
	jobGuid?: string;
	/** Filter by resource ID (supports SQL LIKE patterns). */
	rid?: string;
	/** Filter by segment ID (supports SQL LIKE patterns). */
	sid?: string;
	/** Filter by channel(s) - array for multi-select (exact match). */
	channel?: string[];
	/** Filter by source text (supports SQL LIKE patterns). */
	nsrc?: string;
	/** Filter by target text (supports SQL LIKE patterns). */
	ntgt?: string;
	/** Filter by notes (supports SQL LIKE patterns). */
	notes?: string;
	/** Filter by translation confidence(s) - array of string representations of integers. */
	tconf?: string[];
	/** Maximum rank to include (1 = only active/best translations). Default: 10. */
	maxRank?: number;
	/** If true, only return TUs with translator notes. */
	onlyTNotes?: boolean;
	/** Filter by quality score(s) - array of string representations of integers. */
	q?: string[];
	/** Minimum timestamp (milliseconds since epoch). */
	minTS?: number;
	/** Maximum timestamp (milliseconds since epoch). */
	maxTS?: number;
	/** Filter by provider(s) - array for multi-select (exact match). */
	translationProvider?: string[];
	/** Filter by TM store(s) - array for multi-select. Use '__null__' for NULL values. */
	tmStore?: string[];
	/** Filter by group(s) - array for multi-select. 'Unknown' and 'Unassigned' are special values. */
	group?: string[];
	/** If true, includes channel and group columns (requires CTE join). */
	includeTechnicalColumns?: boolean;
	/** If true, only return TUs that exist in active segment tables (have a channel). */
	onlyLeveraged?: boolean;
}
interface ChannelDAL {
	/** Channel identifier. */
	readonly channelId: string;
	/** Name of the resources table for this channel. */
	readonly resourcesTable: string;
	/** Name of the segments table for this channel. */
	readonly segmentsTable: string;
	/**
	 * Get channel metadata from the table of contents.
	 * @returns Channel metadata or undefined if not found.
	 */
	getChannelMeta(): Promise<ChannelTocRow | undefined>;
	/**
	 * Save channel data by building temporary tables and atomically swapping them.
	 * @param meta - Channel metadata including timestamp and optional snap store ID.
	 * @param cb - Callback function that receives save handlers.
	 * @returns Statistics about saved resources and segments.
	 */
	saveChannel(meta: ChannelMeta, cb: (handlers: {
		saveResource: Function;
		insertResourceRow: Function;
		insertSegmentRow: Function;
	}) => Promise<void>): Promise<{
		resources: number;
		segments: number;
	}>;
	/**
	 * Get a resource by ID.
	 * @param rid - Resource identifier.
	 * @param options - Optional query options.
	 * @returns Resource object or undefined.
	 */
	getResource(rid: string, options?: {
		keepRaw?: boolean;
	}): Promise<ResourceHandle | undefined>;
	/**
	 * Get all desired language pairs from channel segments.
	 * @returns Array of [sourceLang, targetLang] tuples.
	 */
	getDesiredLangPairs(): Promise<Array<[
		string,
		string
	]>>;
	/**
	 * Get active content statistics for this channel.
	 * @returns Statistics object with segment counts by source language.
	 */
	getActiveContentStats(): Promise<Array<{
		prj: string;
		sourceLang: string;
		targetLangs: string;
		segmentCount: number;
		resCount: number;
		lastModified: string;
	}>>;
	/**
	 * Get project table of contents with pagination.
	 * @param prj - Project identifier.
	 * @param offset - Pagination offset.
	 * @param limit - Maximum results.
	 * @returns Array of resource TOC entries.
	 */
	getProjectTOC(prj: string, offset: number, limit: number): Promise<Array<{
		sourceLang: string;
		rid: string;
		modifiedAt: string;
		segmentCount: number;
	}>>;
	/**
	 * Iterate over all resources in the channel.
	 * @param options - Options for fetching resources.
	 * @returns AsyncGenerator yielding normalized resource objects with segments.
	 */
	getAllResources(options?: {
		keepRaw?: boolean;
		prj?: string | string[];
	}): AsyncGenerator<ResourceHandle & {
		segments: NormalizedSegment[];
	}>;
	/**
	 * Get resource row iterator for export.
	 * @returns AsyncGenerator yielding raw resource rows.
	 */
	getResourceRowIterator(): AsyncGenerator<Record<string, unknown>>;
	/**
	 * Get segment row iterator for export.
	 * @returns AsyncGenerator yielding raw segment rows.
	 */
	getSegmentRowIterator(): AsyncGenerator<Record<string, unknown>>;
}
interface TuDAL {
	/**
	 * Get TU entries by their GUIDs.
	 * @param guids - Array of GUIDs to look up.
	 * @returns Map of GUID to TU entry.
	 */
	getEntries(guids: string[]): Promise<Record<string, TU$1>>;
	/**
	 * Get all TU entries for a job.
	 * @param jobGuid - Job GUID.
	 * @returns Array of TU entries.
	 */
	getEntriesByJobGuid(jobGuid: string): Promise<TU$1[]>;
	/**
	 * Save multiple jobs with their translation units in a single transaction.
	 * @param jobs - Array of job objects containing jobProps and tus.
	 * @param options - Options for saving jobs.
	 * @param options.tmStoreId - TM store ID to associate with saved jobs.
	 */
	saveJobs(jobs: Array<{
		jobProps: JobProps$1;
		tus: TU$1[];
	}>, options?: {
		tmStoreId?: string;
		updateRank?: boolean;
	}): Promise<void>;
	/**
	 * Delete a job and its TUs.
	 * @param jobGuid - Job GUID to delete.
	 */
	deleteJob(jobGuid: string): Promise<void>;
	/**
	 * Get exact matches for a normalized source string.
	 * @param nsrc - Normalized source string.
	 * @returns Array of matching TU candidates.
	 */
	getExactMatches(nsrc: NormalizedString$1): Promise<TU$1[]>;
	/**
	 * Delete empty jobs (jobs with no TUs).
	 * @param dryrun - If true, only report what would be deleted.
	 * @returns Count of deleted jobs.
	 */
	deleteEmptyJobs(dryrun?: boolean): Promise<number>;
	/**
	 * Get TU keys (guid, jobGuid) for TUs over a certain rank.
	 * @param maxRank - Maximum rank threshold.
	 * @returns Array of TU keys.
	 */
	tuKeysOverRank(maxRank: number): Promise<Array<[
		string,
		string
	]>>;
	/**
	 * Get TU keys for TUs at a specific quality level.
	 * @param quality - Quality score to match.
	 * @returns Array of TU keys.
	 */
	tuKeysByQuality(quality: number): Promise<Array<[
		string,
		string
	]>>;
	/**
	 * Delete TUs by their keys.
	 * @param tuKeys - Array of TU keys to delete.
	 */
	deleteTuKeys(tuKeys: Array<[
		string,
		string
	]>): Promise<{
		deletedTusCount: number;
		touchedJobsCount: number;
	}>;
	/**
	 * Get statistics for this language pair's TM.
	 * @returns Statistics object.
	 */
	getStats(): Promise<{
		tuCount: number;
		jobCount: number;
		minQ: number;
		maxQ: number;
		minTs: number;
		maxTs: number;
	}>;
	/**
	 * Get translated content status for a channel.
	 * @param channelDAL - Channel DAL instance.
	 * @returns Status by project and source language.
	 */
	getTranslatedContentStatus(channelDAL: ChannelDAL): Promise<Array<{
		prj: string;
		minQ: number;
		q: number;
		res: number;
		seg: number;
		words: number;
		chars: number;
	}>>;
	/**
	 * Get untranslated content status for a channel.
	 * @param channelDAL - Channel DAL instance.
	 * @returns Status by project and source language.
	 */
	getUntranslatedContentStatus(channelDAL: ChannelDAL): Promise<Array<{
		prj: string;
		group: string;
		minQ: number;
		seg: number;
		words: number;
		chars: number;
	}>>;
	/**
	 * Get untranslated content for a channel.
	 * @param channelDAL - Channel DAL instance.
	 * @param options - Query options.
	 * @returns Array of untranslated segments.
	 */
	getUntranslatedContent(channelDAL: ChannelDAL, options?: {
		limit?: number;
		prj?: string | string[];
	}): Promise<NormalizedSegment[]>;
	/**
	 * Query source content with a WHERE condition.
	 * @param channelDAL - Channel DAL instance.
	 * @param whereCondition - SQL WHERE condition.
	 * @returns Array of matching segments.
	 */
	querySource(channelDAL: ChannelDAL, whereCondition: string): Promise<NormalizedSegment[]>;
	/**
	 * Query TUs by their GUIDs with optional channel context.
	 * @param guids - Array of GUIDs to query.
	 * @param channelDAL - Optional channel DAL for context.
	 * @returns Array of TU entries.
	 */
	queryByGuids(guids: string[], channelDAL?: ChannelDAL): Promise<TU$1[]>;
	/**
	 * Search TUs with filtering and pagination.
	 * @param offset - Pagination offset.
	 * @param limit - Maximum results.
	 * @param params - Search filter parameters.
	 * @returns Array of matching TUs.
	 */
	search(offset: number, limit: number, params: TuSearchParams): Promise<TU$1[]>;
	/**
	 * Look up TUs by exact conditions.
	 * @param conditions - Lookup conditions.
	 * @returns Array of matching TUs.
	 */
	lookup(conditions: {
		guid?: string;
		nid?: string;
		rid?: string;
		sid?: string;
	}): Promise<TU$1[]>;
	/**
	 * Get available values for low-cardinality filter columns.
	 * @returns Object with arrays of available values per column.
	 */
	getLowCardinalityColumns(): Promise<Record<string, string[]>>;
	/**
	 * Get quality score distribution.
	 * @returns Array of quality levels with counts.
	 */
	getQualityDistribution(): Promise<Array<{
		q: number;
		count: number;
	}>>;
	/**
	 * Runs a callback in bootstrap mode with deferred index creation.
	 * Automatically creates indexes and updates ranks when the callback completes.
	 * @param callback - The bootstrap operation to run.
	 * @returns The result of the callback.
	 */
	withBootstrapMode<T>(callback: () => Promise<T>): Promise<T>;
	/**
	 * Inserts a batch of jobs in a single transaction without rank updates.
	 * Used during bootstrap for maximum insert performance.
	 * @param jobs - Jobs to insert.
	 * @param tmStoreId - TM store ID.
	 */
	insertJobsForBootstrap(jobs: Array<{
		jobProps: JobProps$1;
		tus: TU$1[];
	}>, tmStoreId: string): void;
}
interface JobDAL {
	/**
	 * Get all available language pairs that have jobs.
	 * @returns Array of [sourceLang, targetLang] tuples.
	 */
	getAvailableLangPairs(): Promise<Array<[
		string,
		string
	]>>;
	/**
	 * Get job statistics grouped by language pair and TM store.
	 * @returns Array of statistics objects.
	 */
	getStats(): Promise<Array<{
		sourceLang: string;
		targetLang: string;
		tmStore: string;
		jobCount: number;
		lastUpdatedAt: string;
	}>>;
	/**
	 * Get job table of contents for a language pair.
	 * @param sourceLang - Source language code (null for all).
	 * @param targetLang - Target language code (null for all).
	 * @returns Array of job TOC entries.
	 */
	getJobTOCByLangPair(sourceLang: string | null, targetLang: string | null): Promise<Array<{
		jobGuid: string;
		status: string;
		translationProvider: string;
		updatedAt: string;
	}>>;
	/**
	 * Set the TM store for a job.
	 * @param jobGuid - Job GUID.
	 * @param tmStoreId - TM store identifier.
	 */
	setJobTmStore(jobGuid: string, tmStoreId: string): Promise<void>;
	/**
	 * Get a job by its GUID.
	 * @param jobGuid - Job GUID.
	 * @returns Job object or undefined.
	 */
	getJob(jobGuid: string): Promise<JobProps$1 | undefined>;
	/**
	 * Get total job count.
	 * @returns Number of jobs.
	 */
	getJobCount(): Promise<number>;
	/**
	 * Get job deltas between local DB and remote TOC.
	 * @param sourceLang - Source language code.
	 * @param targetLang - Target language code.
	 * @param toc - Remote table of contents.
	 * @param storeId - TM store ID.
	 * @returns Array of delta entries.
	 */
	getJobDeltas(sourceLang: string, targetLang: string, toc: TMStoreTOC, storeId: string): Promise<Array<{
		tmStore: string;
		blockId: string;
		localJobGuid: string | null;
		remoteJobGuid: string | null;
		localUpdatedAt: string | null;
		remoteUpdatedAt: string | null;
	}>>;
	/**
	 * Get valid job IDs for a block.
	 * @param sourceLang - Source language code.
	 * @param targetLang - Target language code.
	 * @param toc - Table of contents.
	 * @param blockId - Block identifier.
	 * @param storeId - TM store ID.
	 * @returns Array of job GUIDs.
	 */
	getValidJobIds(sourceLang: string, targetLang: string, toc: TMStoreTOC, blockId: string, storeId: string): Promise<string[]>;
}
interface DALManager {
	/** Active channel IDs. */
	activeChannels: Set<string>;
	/**
	 * Initialize the DAL manager.
	 * @param mm - MonsterManager instance.
	 */
	init(mm: MonsterManager): Promise<void>;
	/**
	 * Get a channel DAL by ID.
	 * @param channelId - Channel identifier.
	 * @returns Channel DAL instance.
	 */
	channel(channelId: string): ChannelDAL;
	/**
	 * Get a TU DAL for a language pair.
	 * @param sourceLang - Source language code.
	 * @param targetLang - Target language code.
	 * @returns TU DAL instance.
	 */
	tu(sourceLang: string, targetLang: string): TuDAL;
	/**
	 * Get the job DAL.
	 */
	readonly job: JobDAL;
	/**
	 * Runs a callback in bootstrap mode with optimal bulk insert settings.
	 * Automatically cleans up and switches back to normal WAL mode when done.
	 * @param callback - The bootstrap operation to run.
	 * @returns The result of the callback.
	 */
	withBootstrapMode<T>(callback: () => Promise<T>): Promise<T>;
	/**
	 * Shutdown the DAL manager.
	 */
	shutdown(): Promise<void>;
}
declare class Normalizer {
	/**
	 * Creates a new Normalizer instance.
	 * @param {NormalizerConstructorOptions} options - Constructor options.
	 */
	constructor({ decoders, textEncoders, codeEncoders, joiner }: NormalizerConstructorOptions);
	join: Joiner;
	/**
	 * Decodes a raw string into a normalized string (array of parts).
	 * @param {string} str - The raw string to decode.
	 * @param {EncodeFlags} [flags] - Optional flags passed to decoders.
	 * @returns {NormalizedString} Array of parts (text strings and placeholder objects).
	 */
	decode(str: string, flags?: EncodeFlags$1): NormalizedString$2;
	/**
	 * Encodes a text part for output.
	 * @param {string} text - The text to encode.
	 * @param {EncodeFlags} [flags] - Encoding context flags.
	 * @returns {string} The encoded string representation.
	 */
	encodeText(text: string, flags?: EncodeFlags$1): string;
	/**
	 * Encodes a placeholder part for output.
	 * @param {PlaceholderPart} part - The placeholder part to encode.
	 * @param {EncodeFlags} [flags] - Encoding context flags.
	 * @returns {string} The encoded string representation.
	 */
	encodeCode(part: PlaceholderPart$1, flags?: EncodeFlags$1): string;
	/**
	 * Encodes a single part (text or placeholder) for output.
	 * @param {Part} part - The part to encode.
	 * @param {EncodeFlags} [flags] - Encoding context flags.
	 * @returns {string} The encoded string representation.
	 */
	encodePart(part: Part$1, flags?: EncodeFlags$1): string;
	#private;
}
type NormalizedString$2 = NormalizedString$7;
type Part$1 = Part$6;
type PlaceholderPart$1 = PlaceholderPart$5;
type EncodeFlags$1 = EncodeFlags$4;
type DecoderFunction$1 = DecoderFunction$4;
type TextEncoderFunction$1 = TextEncoderFunction$3;
type CodeEncoderFunction$1 = CodeEncoderFunction$2;
type Joiner = (parts: string[]) => string;
type NormalizerConstructorOptions = {
	/**
	 * - Array of decoder functions for parsing strings.
	 */
	decoders: DecoderFunction$1[];
	/**
	 * - Array of encoder functions for text parts.
	 */
	textEncoders?: TextEncoderFunction$1[];
	/**
	 * - Array of encoder functions for placeholder parts.
	 */
	codeEncoders?: CodeEncoderFunction$1[];
	/**
	 * - Function to join encoded parts (defaults to simple concatenation).
	 */
	joiner?: Joiner;
};
declare class TM {
	/**
	 * Maximum TUs per transaction when saving TM blocks.
	 * Larger values reduce transaction overhead but increase memory usage.
	 */
	static MAX_TUS_PER_TRANSACTION: number;
	/**
	 * Creates a new TM instance for a language pair.
	 * @param {string} sourceLang - Source language code.
	 * @param {string} targetLang - Target language code.
	 * @param {DALManager} DAL - Data Access Layer manager.
	 */
	constructor(sourceLang: string, targetLang: string, DAL: DALManager$1);
	/** @type {string} Source language code. */
	sourceLang: string;
	/** @type {string} Target language code. */
	targetLang: string;
	/**
	 * Gets TU entries by their GUIDs.
	 * @param {string[]} guids - Array of TU GUIDs.
	 * @returns {Promise<Record<string, TU>>} Map of GUID to TU entry.
	 */
	getEntries(guids: string[]): Promise<Record<string, TU$2>>;
	/**
	 * Gets all TU entries for a job.
	 * @param {string} jobGuid - Job identifier.
	 * @returns {Promise<TU[]>} Array of TU entries.
	 */
	getEntriesByJobGuid(jobGuid: string): Promise<TU$2[]>;
	/**
	 * Finds TU entries with exact matching normalized source.
	 * Filters to only return entries with compatible placeholders.
	 * @param {NormalizedString} nsrc - Normalized source to match.
	 * @returns {Promise<TU[]>} Array of matching TU entries.
	 */
	getExactMatches(nsrc: NormalizedString$3): Promise<TU$2[]>;
	/**
	 * Gets statistics for this language pair.
	 * @returns {Promise<TMStats>} TM statistics.
	 */
	getStats(): Promise<TMStats>;
	/**
	 * Gets translation status for content in a channel, grouped by project.
	 * @param {string} channelId - Channel identifier.
	 * @returns {Promise<Object>} Status grouped by project.
	 */
	getTranslatedContentStatus(channelId: string): Promise<any>;
	/**
	 * Gets untranslated content status for a channel, grouped by project and group.
	 * @param {string} channelId - Channel identifier.
	 * @returns {Promise<Object>} Status grouped by project -> group.
	 */
	getUntranslatedContentStatus(channelId: string): Promise<any>;
	/**
	 * Get untranslated content from a channel.
	 * @param {string} channelId - The channel ID to query.
	 * @param {Object} [options] - Options for the query.
	 * @param {number} [options.limit=5000] - Maximum number of segments to return.
	 * @param {string[]} [options.prj] - Array of project names to filter by.
	 * @returns {Promise<Object[]>} Array of untranslated translation units.
	 */
	getUntranslatedContent(channelId: string, { limit, prj }?: {
		limit?: number;
		prj?: string[];
	}): Promise<any[]>;
	/**
	 * Queries source segments matching a WHERE condition.
	 * @param {string} channelId - Channel identifier.
	 * @param {string} whereCondition - SQL WHERE clause.
	 * @returns {Promise<Object[]>} Array of matching source segments.
	 */
	querySource(channelId: string, whereCondition: string): Promise<any[]>;
	/**
	 * Queries TUs by GUIDs, optionally filtered by channel.
	 * @param {string[]} guids - Array of TU GUIDs.
	 * @param {string} [channelId] - Optional channel filter.
	 * @returns {Promise<TU[]>} Array of TU entries.
	 */
	queryByGuids(guids: string[], channelId?: string): Promise<TU$2[]>;
	/**
	 * Searches TUs with LIKE conditions and pagination.
	 * @param {number} offset - Pagination offset.
	 * @param {number} limit - Maximum results.
	 * @param {import('../interfaces.js').TuSearchParams} [likeConditions] - Search filter options.
	 * @returns {Promise<Object[]>} Array of matching translation units.
	 */
	search(offset: number, limit: number, likeConditions?: TuSearchParams): Promise<any[]>;
	/**
	 * Looks up TUs matching exact conditions.
	 * @param {LookupConditions} [conditions] - Exact match conditions.
	 * @returns {Promise<TU[]>} Array of matching TU entries.
	 */
	lookup(conditions?: LookupConditions): Promise<TU$2[]>;
	/**
	 * Gets available filter options for low-cardinality columns.
	 * @returns {Promise<Object>} Available filter values per column.
	 */
	getLowCardinalityColumns(): Promise<any>;
	/**
	 * Deletes jobs that have no translation units.
	 * @param {boolean} [dryrun] - If true, only return count without deleting.
	 * @returns {Promise<number>} Number of deleted jobs (or count if dryrun).
	 */
	deleteEmptyJobs(dryrun?: boolean): Promise<number>;
	/**
	 * Get TU keys (guid, jobGuid tuples) where rank exceeds the specified maximum.
	 * @param {number} maxRank - Maximum rank threshold.
	 * @returns {Promise<[string, string][]>} Array of [guid, jobGuid] tuples identifying TUs to delete.
	 */
	tuKeysOverRank(maxRank: number): Promise<[
		string,
		string
	][]>;
	/**
	 * Get TU keys (guid, jobGuid tuples) with a specific quality score.
	 * @param {number} quality - Quality score to match.
	 * @returns {Promise<[string, string][]>} Array of [guid, jobGuid] tuples identifying TUs to delete.
	 */
	tuKeysByQuality(quality: number): Promise<[
		string,
		string
	][]>;
	/**
	 * Delete TUs identified by their composite keys (guid, jobGuid tuples).
	 * @param {[string, string][]} tuKeys - Array of [guid, jobGuid] tuples identifying TUs to delete.
	 * @returns {Promise<{deletedTusCount: number, touchedJobsCount: number}>} Count of deleted TUs and touched jobs.
	 */
	deleteTuKeys(tuKeys: [
		string,
		string
	][]): Promise<{
		deletedTusCount: number;
		touchedJobsCount: number;
	}>;
	/**
	 * Gets the distribution of TUs by quality score.
	 * @returns {Promise<Array<{ q: number, count: number }>>} Array of quality/count pairs.
	 */
	getQualityDistribution(): Promise<Array<{
		q: number;
		count: number;
	}>>;
	/**
	 * Saves a TM block (iterator of jobs) to the database with chunked transactions.
	 * Jobs are batched together until adding the next job would exceed MAX_TUS_PER_TRANSACTION.
	 * @param {AsyncIterable<JobPropsTusPair>} tmBlockIterator - Iterator yielding job/TU pairs.
	 * @param {Object} [options] - Options for saving the TM block.
	 * @param {string} [options.tmStoreId] - TM store ID to associate with saved jobs.
	 * @param {boolean} [options.updateRank=true] - Whether to update TU ranks after saving.
	 * @returns {Promise<{jobs: Object[], tuCount: number}>} Saved job properties and total TU count.
	 */
	saveTmBlock(tmBlockIterator: AsyncIterable<JobPropsTusPair$1>, { tmStoreId, updateRank }?: {
		tmStoreId?: string;
		updateRank?: boolean;
	}): Promise<{
		jobs: any[];
		tuCount: number;
	}>;
	/**
	 * Bootstraps this language pair with bulk data from a job iterator.
	 * This is a destructive operation - the TM database should be wiped before calling.
	 * Jobs are batched by TU count to keep transaction sizes manageable.
	 * @param {AsyncIterable<JobPropsTusPair>} jobIterator - Iterator yielding job/TU pairs.
	 * @param {string} tmStoreId - TM store ID to associate with saved jobs.
	 * @returns {Promise<{jobCount: number, tuCount: number}>} Statistics about loaded data.
	 */
	bootstrap(jobIterator: AsyncIterable<JobPropsTusPair$1>, tmStoreId: string): Promise<{
		jobCount: number;
		tuCount: number;
	}>;
	#private;
}
type TU$2 = TU$1;
type NormalizedString$3 = NormalizedString$1;
type DALManager$1 = DALManager;
type JobPropsTusPair$1 = JobPropsTusPair;
type TMStats = {
	/**
	 * - Total translation units.
	 */
	tuCount: number;
	/**
	 * - Total jobs.
	 */
	jobCount: number;
};
type LookupConditions = {
	/**
	 * - Filter by GUID.
	 */
	guid?: string;
	/**
	 * - Filter by job GUID.
	 */
	jobGuid?: string;
	/**
	 * - Filter by resource ID.
	 */
	rid?: string;
	/**
	 * - Filter by segment ID.
	 */
	sid?: string;
	/**
	 * - Filter by source text (exact).
	 */
	src?: string;
	/**
	 * - Filter by target text (exact).
	 */
	tgt?: string;
	/**
	 * - Filter by provider ID.
	 */
	translationProvider?: string;
	/**
	 * - Minimum quality score.
	 */
	minQ?: number;
	/**
	 * - Maximum quality score.
	 */
	maxQ?: number;
};
declare class FormatHandler {
	/**
	 * Creates a new FormatHandler instance.
	 * @param {FormatHandlerConstructorOptions} options - Constructor options.
	 * @throws {Error} If resourceFilter is not provided.
	 */
	constructor({ id, resourceFilter, resourceGenerator, normalizers, defaultMessageFormat, segmentDecorators, formatHandlers }: FormatHandlerConstructorOptions);
	/**
	 * Returns information about this format handler's configuration.
	 * @returns {FormatHandlerInfo} Format handler configuration summary.
	 */
	getInfo(): FormatHandlerInfo;
	/**
	 * Parses and normalizes a raw resource into segments.
	 * @param {string} rid - Resource identifier.
	 * @param {string} resource - Raw resource content.
	 * @param {GetNormalizedResourceOptions} [options] - Normalization options.
	 * @returns {Promise<NormalizedResource>} Normalized resource with segments.
	 */
	getNormalizedResource(rid: string, resource: string, options?: GetNormalizedResourceOptions): Promise<NormalizedResource>;
	/**
	 * Generates translated raw resource content from a resource handle and translation memory.
	 * @param {ResourceHandle} resHandle - The source resource handle with segments.
	 * @param {TM} tm - Translation memory instance for the target language.
	 * @returns {Promise<string|undefined>} The generated raw translated content, or undefined if generation fails.
	 */
	generateTranslatedResource(resHandle: ResourceHandle$1, tm: TM$1): Promise<string | undefined>;
	#private;
}
type ResourceFilter$1 = ResourceFilter$4;
type ResourceGenerator$1 = ResourceGenerator$3;
type ResourceHandle$1 = ResourceHandle$2;
type NormalizedSegment$1 = NormalizedSegment$2;
type NormalizedResource = NormalizedResource$1;
type TM$1 = TM;
type SegmentDecorator$1 = (segment: NormalizedSegment$1) => NormalizedSegment$1 | undefined;
type FormatHandlerConstructorOptions = {
	/**
	 * - Unique format handler identifier.
	 */
	id: string;
	/**
	 * - Filter for parsing raw resources.
	 */
	resourceFilter: ResourceFilter$1;
	/**
	 * - Generator for producing translations (defaults to resourceFilter).
	 */
	resourceGenerator?: ResourceGenerator$1;
	/**
	 * - Map of message format ID to Normalizer.
	 */
	normalizers: {
		[x: string]: Normalizer;
	};
	/**
	 * - Default message format for segments without explicit format.
	 */
	defaultMessageFormat: string;
	/**
	 * - Array of decorators to apply to segments.
	 */
	segmentDecorators?: SegmentDecorator$1[];
	/**
	 * - Map of format handlers for processing subresources.
	 */
	formatHandlers?: {
		[x: string]: FormatHandler;
	};
};
type FormatHandlerInfo = {
	/**
	 * - Format handler identifier.
	 */
	id: string;
	/**
	 * - Resource filter class name.
	 */
	resourceFilter: string;
	/**
	 * - Resource generator class name.
	 */
	resourceGenerator: string;
	/**
	 * - Available message format IDs.
	 */
	messageFormats: string[];
	/**
	 * - Default message format ID.
	 */
	defaultMessageFormat: string;
};
type GetNormalizedResourceOptions = {
	/**
	 * - Whether this is a source (true) or target (false) resource.
	 */
	isSource: boolean;
	/**
	 * - Source language code.
	 */
	sourceLang: string;
	/**
	 * - Target language codes.
	 */
	targetLangs?: string[];
};
declare class ResourceHandle$2 {
	/**
	 * Creates a new ResourceHandle instance.
	 * @param {ResourceHandleConstructorOptions} options - Constructor options.
	 */
	constructor({ id, channel, modified, resourceFormat, formatHandler, sourceLang, targetLangs, plan, prj, raw, segments, subresources, ...other }: ResourceHandleConstructorOptions);
	id: string;
	channel: string;
	modified: string | number;
	resourceFormat: string;
	sourceLang: string;
	targetLangs: string[];
	plan: TranslationPlan;
	prj: string;
	raw: string;
	segments: NormalizedSegment[];
	subresources: Subresource[];
	/**
	 * Loads segments and subresources from a normalized resource.
	 * @param {NormalizedResource} normalizedResource - The normalized resource data.
	 * @returns {ResourceHandle} This instance for chaining.
	 */
	loadFromNormalizedResource(normalizedResource: NormalizedResource$1): ResourceHandle$2;
	/**
	 * Loads and normalizes a resource from raw content using the format handler.
	 * @param {string} rawResource - Raw resource content.
	 * @param {LoadResourceOptions} options - Load options.
	 * @returns {Promise<ResourceHandle>} This instance for chaining.
	 */
	loadResourceFromRaw(rawResource: string, options: LoadResourceOptions): Promise<ResourceHandle$2>;
	/**
	 * Generates translated raw resource content from the current segments and TM.
	 * @param {TM} tm - Translation memory instance for looking up translations.
	 * @returns {Promise<string>} The generated raw translated content.
	 */
	generateTranslatedRawResource(tm: TM$2): Promise<string>;
	/**
	 * Applies translation policies to all segments, updating their translation plans.
	 * @param {TranslationPolicy[]} translationPolicyPipeline - Array of policy functions to apply.
	 * @returns {Promise<void>}
	 */
	applyPolicies(translationPolicyPipeline: TranslationPolicy$1[]): Promise<void>;
	#private;
}
type TranslationPolicy$1 = TranslationPolicy$5;
type NormalizedSegment$2 = NormalizedSegment$5;
type TranslationPlan$1 = TranslationPlan$3;
type Subresource$1 = Subresource$2;
type FormatHandler$1 = FormatHandler;
type TM$2 = TM;
type NormalizedResource$1 = {
	/**
	 * - Array of normalized segments.
	 */
	segments: NormalizedSegment$2[];
	/**
	 * - Optional nested subresources.
	 */
	subresources?: Subresource$1[];
};
type LoadResourceOptions = {
	/**
	 * - Whether this is a source (true) or target (false) resource.
	 */
	isSource: boolean;
};
type ResourceHandleConstructorOptions = {
	/**
	 * - Resource identifier.
	 */
	id: string;
	/**
	 * - Channel ID this resource belongs to.
	 */
	channel: string;
	/**
	 * - Last modified timestamp.
	 */
	modified?: string | number;
	/**
	 * - Format handler ID.
	 */
	resourceFormat: string;
	/**
	 * - Format handler instance.
	 */
	formatHandler: FormatHandler$1;
	/**
	 * - Source language code.
	 */
	sourceLang: string;
	/**
	 * - Target language codes.
	 */
	targetLangs?: string[];
	/**
	 * - Translation plan.
	 */
	plan?: TranslationPlan$1;
	/**
	 * - Project name for filtering.
	 */
	prj?: string;
	/**
	 * - Raw resource content.
	 */
	raw?: string;
	/**
	 * - Parsed segments.
	 */
	segments?: NormalizedSegment$2[];
	/**
	 * - Nested subresources.
	 */
	subresources?: Subresource$1[];
};
declare class Channel$1 {
	/**
	 * Creates a new Channel instance.
	 * @param {ChannelConstructorOptions} options - Channel configuration options.
	 */
	constructor({ id, source, formatHandlers, defaultResourceFormat, target, translationPolicyPipeline }: ChannelConstructorOptions);
	/**
	 * Returns information about this channel's configuration.
	 * @returns {ChannelInfo} Channel configuration summary.
	 */
	getInfo(): ChannelInfo;
	/**
	 * Creates a ResourceHandle from a resource header.
	 * @param {ResourceHeader} resourceHeader - Resource metadata from source adapter.
	 * @returns {ResourceHandle} A new ResourceHandle configured for this resource.
	 * @throws {Error} If sourceLang is missing or no format handler is found.
	 */
	makeResourceHandleFromHeader(resourceHeader: ResourceHeader$1): ResourceHandle$2;
	/**
	 * Fetches all resources from the source, normalizes them, and applies translation policies.
	 * @param {object} [options] - Options passed to the source adapter's fetchAllResources.
	 * @yields {ResourceHandle} Normalized resource handles with policies applied.
	 * @returns {AsyncGenerator<ResourceHandle>} Async generator of ResourceHandle instances.
	 */
	getAllNormalizedResources(options?: object): AsyncGenerator<ResourceHandle$2>;
	/**
	 * Fetches an existing translated resource from the target adapter.
	 * @param {ResourceHandle} resourceHandle - The source resource handle.
	 * @param {string} targetLang - Target language code.
	 * @returns {Promise<ResourceHandle>} A ResourceHandle loaded with the existing translation.
	 */
	getExistingTranslatedResource(resourceHandle: ResourceHandle$2, targetLang: string): Promise<ResourceHandle$2>;
	/**
	 * Commits a translated resource to the target adapter.
	 * @param {string} targetLang - Target language code.
	 * @param {string} resourceId - Source resource identifier.
	 * @param {string} rawResource - Raw translated content to commit.
	 * @returns {Promise<string>} The translated resource ID in the target system.
	 */
	commitTranslatedResource(targetLang: string, resourceId: string, rawResource: string): Promise<string>;
	#private;
}
type SourceAdapter$1 = SourceAdapter$5;
type TargetAdapter$1 = TargetAdapter$4;
type ResourceHeader$1 = ResourceHeader$2;
type TranslationPolicy$2 = TranslationPolicy$5;
type FormatHandlerInfo$1 = FormatHandlerInfo;
type ChannelConstructorOptions = {
	/**
	 * - Unique channel identifier.
	 */
	id: string;
	/**
	 * - Source adapter for fetching resources.
	 */
	source: SourceAdapter$1;
	/**
	 * - Map of format ID to FormatHandler.
	 */
	formatHandlers: {
		[x: string]: FormatHandler;
	};
	/**
	 * - Default format handler ID.
	 */
	defaultResourceFormat: string;
	/**
	 * - Target adapter for committing translations.
	 */
	target: TargetAdapter$1;
	/**
	 * - Array of translation policy functions.
	 */
	translationPolicyPipeline: TranslationPolicy$2[];
};
type ChannelInfo = {
	/**
	 * - Channel identifier.
	 */
	id: string;
	/**
	 * - Source adapter class name.
	 */
	source: string;
	/**
	 * - Target adapter class name.
	 */
	target: string;
	/**
	 * - Array of format handler info objects.
	 */
	formatHandlers: FormatHandlerInfo$1[];
	/**
	 * - Default format handler ID.
	 */
	defaultResourceFormat: string;
	/**
	 * - Number of translation policies.
	 */
	translationPolicies: number;
};
declare class ResourceManager {
	/**
	 * Creates a new ResourceManager instance.
	 * @param {DALManager} dal - Data Access Layer manager for database operations.
	 * @param {ResourceManagerConstructorOptions} options - Constructor options.
	 */
	constructor(dal: DALManager$2, { channels, autoSnap, snapStores }: ResourceManagerConstructorOptions);
	/**
	 * Initializes the ResourceManager.
	 * @param {import('../monsterManager/index.js').MonsterManager} mm - The MonsterManager instance.
	 * @returns {Promise<void>}
	 */
	init(mm: MonsterManager$1): Promise<void>;
	/**
	 * Gets the list of configured channel IDs.
	 * @returns {string[]} Array of channel identifiers.
	 */
	get channelIds(): string[];
	/**
	 * Gets metadata for a channel (timestamp, store info).
	 * @param {string} channelId - Channel identifier.
	 * @returns {Promise<import('../interfaces.js').ChannelTocRow | undefined>} Channel metadata object or undefined.
	 */
	getChannelMeta(channelId: string): Promise<ChannelTocRow | undefined>;
	/**
	 * Gets the list of configured snap store IDs.
	 * @returns {string[]} Array of snap store identifiers.
	 */
	get snapStoreIds(): string[];
	/**
	 * Gets information about a snap store.
	 * @param {string} snapStoreId - Snap store identifier.
	 * @returns {SnapStoreInfo} Snap store information.
	 */
	getSnapStoreInfo(snapStoreId: string): SnapStoreInfo;
	/**
	 * Gets the table of contents for a snap store.
	 * @param {string} snapStoreId - Snap store identifier.
	 * @returns {Promise<Object>} Table of contents with channel snapshots.
	 */
	getSnapStoreTOC(snapStoreId: string): Promise<any>;
	/**
	 * Returns a channel given its id.
	 *
	 * @param {string} channelId String identifier of the channel.
	 * @return {Channel} A channel object.
	 */
	getChannel(channelId: string): Channel$2;
	/**
	 * Gets all desired language pairs for a channel based on translation policies.
	 * @param {string} channelId - Channel identifier.
	 * @returns {Promise<Array<[string, string]>>} Array of [sourceLang, targetLang] pairs.
	 */
	getDesiredLangPairs(channelId: string): Promise<Array<[
		string,
		string
	]>>;
	/**
	 * Gets desired target languages for a channel, optionally filtered.
	 * @param {string} channelId - Channel identifier.
	 * @param {string[]|string} [limitToLang] - Language or list of languages to limit to.
	 * @returns {Promise<string[]>} Sorted array of target language codes.
	 * @throws {Error} If any specified language is not in the desired list.
	 */
	getDesiredTargetLangs(channelId: string, limitToLang?: string[] | string): Promise<string[]>;
	/**
	 * Gets statistics about active content in a channel.
	 * @param {string} channelId - Channel identifier.
	 * @returns {Promise<ActiveContentStats[]>} Array of content statistics per resource.
	 */
	getActiveContentStats(channelId: string): Promise<ActiveContentStats[]>;
	/**
	 * Gets paginated table of contents for a project within a channel.
	 * @param {string} channelId - Channel identifier.
	 * @param {string} prj - Project name.
	 * @param {number} [offset=0] - Pagination offset.
	 * @param {number} [limit=1000] - Maximum number of results.
	 * @returns {Promise<Object[]>} Array of resource entries.
	 */
	getProjectTOC(channelId: string, prj: string, offset?: number, limit?: number): Promise<any[]>;
	/**
	 * Gets a resource handle by ID from the cached snapshot.
	 * @param {string} channelId - Channel identifier.
	 * @param {string} rid - Resource identifier.
	 * @param {Object} [options] - Options for fetching the resource.
	 * @param {boolean} [options.keepRaw=false] - Whether to include raw content.
	 * @returns {Promise<ResourceHandle>} The resource handle.
	 */
	getResourceHandle(channelId: string, rid: string, options?: {
		keepRaw?: boolean;
	}): Promise<ResourceHandle$3>;
	/**
	 * Iterates over all resources in a channel from the cached snapshot.
	 * @param {string} channelId - Channel identifier.
	 * @param {Object} [options] - Options for fetching resources.
	 * @param {boolean} [options.keepRaw=false] - Whether to include raw content.
	 * @param {string} [options.prj] - Filter by project name.
	 * @yields {ResourceHandle} Resource handles.
	 * @returns {AsyncGenerator<ResourceHandle>} Async generator of resource handles.
	 */
	getAllResources(channelId: string, options?: {
		keepRaw?: boolean;
		prj?: string;
	}): AsyncGenerator<ResourceHandle$3>;
	/**
	 * @param {string} channelId
	 * @returns {Promise<{resources: number, segments: number}>}
	 */
	snap(channelId: string): Promise<{
		resources: number;
		segments: number;
	}>;
	/**
	 * @param {number} ts
	 * @param {string} channelId
	 * @param {string} snapStoreId
	 * @returns {Promise<{resources: number, segments: number}>}
	 */
	import(ts: number, channelId: string, snapStoreId: string): Promise<{
		resources: number;
		segments: number;
	}>;
	/**
	 * Exports a channel snapshot to an external snap store.
	 * @param {string} channelId - Channel identifier.
	 * @param {string} snapStoreId - Snap store identifier.
	 * @returns {Promise<{ts?: number, resources?: number, segments?: number}>} Export stats.
	 */
	export(channelId: string, snapStoreId: string): Promise<{
		ts?: number;
		resources?: number;
		segments?: number;
	}>;
	/**
	 * Cleans up resources on shutdown.
	 * @returns {Promise<void>}
	 */
	shutdown(): Promise<void>;
	#private;
}
type Channel$2 = Channel$1;
type ResourceHandle$3 = ResourceHandle$2;
type DALManager$2 = DALManager$4;
type ResourceManagerConstructorOptions = {
	/**
	 * - Map of channel ID to Channel instance.
	 */
	channels?: {
		[x: string]: Channel$1;
	};
	/**
	 * - Whether to automatically snapshot channels on first access.
	 */
	autoSnap?: boolean;
	/**
	 * - Map of snap store ID to SnapStore instance.
	 */
	snapStores?: {
		[x: string]: SnapStore;
	};
};
type ActiveContentStats = {
	/**
	 * - Project name.
	 */
	prj: string;
	/**
	 * - Source language code.
	 */
	sourceLang: string;
	/**
	 * - Target languages for this resource.
	 */
	targetLangs: string[];
	/**
	 * - Number of segments.
	 */
	segmentCount: number;
	/**
	 * - Number of resources.
	 */
	resCount: number;
	/**
	 * - Last modification timestamp.
	 */
	lastModified: string;
};
type SnapStoreInfo = {
	/**
	 * - Snap store identifier.
	 */
	id: string;
	/**
	 * - Snap store class name.
	 */
	type: string;
};
declare class TMManager {
	/**
	 * Creates a new TMManager instance.
	 * @param {DALManager} dal - Data Access Layer manager for database operations.
	 * @param {Record<string, TMStore>} [tmStores] - Map of TM store ID to TMStore instance.
	 */
	constructor(dal: DALManager$3, tmStores?: Record<string, TMStore$1>);
	/**
	 * Initializes the TMManager and all configured TM stores.
	 * @param {import('../monsterManager/index.js').MonsterManager} mm - The MonsterManager instance.
	 * @returns {Promise<void>}
	 */
	init(mm: MonsterManager$1): Promise<void>;
	/**
	 * Generates a unique job GUID (deterministic in regression mode).
	 * @returns {Promise<string>} A unique job identifier.
	 */
	generateJobGuid(): Promise<string>;
	/**
	 * Gets a TM instance for a language pair (cached).
	 * @param {string} sourceLang - Source language code.
	 * @param {string} targetLang - Target language code.
	 * @returns {TM} The TM instance for querying translations.
	 */
	getTM(sourceLang: string, targetLang: string): TM;
	/**
	 * Gets a TM store by ID (case-insensitive lookup).
	 * @param {string} id - TM store identifier.
	 * @returns {TMStore} The TM store instance.
	 * @throws {Error} If the TM store is not found.
	 */
	getTmStore(id: string): TMStore$1;
	/**
	 * Gets information about a TM store.
	 * @param {string} id - TM store identifier.
	 * @returns {TmStoreInfo} TM store information.
	 */
	getTmStoreInfo(id: string): TmStoreInfo;
	/**
	 * Gets tables of contents for all language pairs in a TM store.
	 * @param {TMStore} tmStore - The TM store to query.
	 * @param {number} [parallelism=8] - Number of parallel TOC fetches.
	 * @returns {Promise<Array<[string, string, Object]>>} Array of [sourceLang, targetLang, TOC] tuples.
	 */
	getTmStoreTOCs(tmStore: TMStore$1, parallelism?: number): Promise<Array<[
		string,
		string,
		any
	]>>;
	/**
	 * Gets the list of configured TM store IDs.
	 * @returns {string[]} Array of TM store identifiers.
	 */
	get tmStoreIds(): string[];
	/**
	 * Synchronizes translations from a remote TM store to local database.
	 * @param {TMStore} tmStore - The TM store to sync from.
	 * @param {SyncDownOptions} options - Sync options.
	 * @returns {Promise<SyncDownStats[]>} Array of sync statistics per language pair.
	 */
	syncDown(tmStore: TMStore$1, { dryrun, sourceLang, targetLang, deleteExtraJobs, eraseParentTmStore, storeAlias, parallelism }: SyncDownOptions): Promise<SyncDownStats[]>;
	/**
	 * Synchronizes translations from local database to a remote TM store.
	 * @param {TMStore} tmStore - The TM store to sync to.
	 * @param {SyncUpOptions} options - Sync options.
	 * @returns {Promise<SyncUpStats[]>} Array of sync statistics per language pair.
	 */
	syncUp(tmStore: TMStore$1, { dryrun, sourceLang, targetLang, deleteEmptyBlocks, includeUnassigned, assignUnassigned, storeAlias, parallelism }: SyncUpOptions): Promise<SyncUpStats[]>;
	/**
	 * Gets all available language pairs from the job database.
	 * @returns {Promise<Array<[string, string]>>} Array of [sourceLang, targetLang] pairs.
	 */
	getAvailableLangPairs(): Promise<Array<[
		string,
		string
	]>>;
	/**
	 * Gets TM statistics grouped by language pair.
	 * @returns {Promise<Object>} Statistics grouped by sourceLang -> targetLang.
	 */
	getStats(): Promise<any>;
	/**
	 * Gets job table of contents for a language pair.
	 * @param {string} sourceLang - Source language code.
	 * @param {string} targetLang - Target language code.
	 * @returns {Promise<Object[]>} Array of job entries with metadata.
	 */
	getJobTOCByLangPair(sourceLang: string, targetLang: string): Promise<any[]>;
	/**
	 * Gets a job by GUID including its translation units.
	 * @param {string} jobGuid - Job identifier.
	 * @returns {Promise<Job|undefined>} The job with TUs, or undefined if not found.
	 */
	getJob(jobGuid: string): Promise<Job$1 | undefined>;
	/**
	 * Yields job properties and TUs for a list of job GUIDs.
	 * @param {string[]} jobGuids - Array of job identifiers.
	 * @yields {JobPropsTusPair} Job properties and TUs pair.
	 * @returns {AsyncGenerator<JobPropsTusPair>} Async generator of job/TU pairs.
	 */
	getJobPropsTusPair(jobGuids: string[]): AsyncGenerator<JobPropsTusPair$2>;
	/**
	 * Yields all jobs for a language pair.
	 * @param {string} sourceLang - Source language code.
	 * @param {string} targetLang - Target language code.
	 * @yields {Job} Jobs with TUs.
	 * @returns {AsyncGenerator<Job>} Async generator of jobs.
	 */
	getAllJobs(sourceLang: string, targetLang: string): AsyncGenerator<Job$1>;
	/**
	 * Deletes a job and all its translation units.
	 * @param {string} jobGuid - Job identifier to delete.
	 * @throws {Error} If the job does not exist.
	 * @returns {Promise<void>}
	 */
	deleteJob(jobGuid: string): Promise<void>;
	/**
	 * Bootstraps the TM database from a TM store.
	 * This is a DESTRUCTIVE operation that wipes all existing TM data.
	 *
	 * @param {TMStore} tmStore - The TM store to bootstrap from.
	 * @param {Object} options - Bootstrap options.
	 * @param {boolean} [options.dryrun=false] - If true, only report what would be done.
	 * @param {string} [options.sourceLang] - Filter to specific source language.
	 * @param {string} [options.targetLang] - Filter to specific target language.
	 * @param {number} [options.parallelism=4] - Number of parallel operations.
	 * @returns {Promise<{pairs: Array<[string, string]>, stats?: Array<{sourceLang: string, targetLang: string, jobCount: number, tuCount: number}>, dryrun: boolean}>}
	 */
	bootstrap(tmStore: TMStore$1, { dryrun, sourceLang, targetLang, parallelism }?: {
		dryrun?: boolean;
		sourceLang?: string;
		targetLang?: string;
		parallelism?: number;
	}): Promise<{
		pairs: Array<[
			string,
			string
		]>;
		stats?: Array<{
			sourceLang: string;
			targetLang: string;
			jobCount: number;
			tuCount: number;
		}>;
		dryrun: boolean;
	}>;
	#private;
}
type TMStore$1 = TMStore$4;
type JobPropsTusPair$2 = JobPropsTusPair$5;
type Job$1 = Job$6;
type DALManager$3 = DALManager$4;
type TmStoreInfo = {
	/**
	 * - TM store identifier.
	 */
	id: string;
	/**
	 * - TM store class name.
	 */
	type: string;
	/**
	 * - Access permissions ('readwrite', 'readonly', 'writeonly').
	 */
	access: string;
	/**
	 * - Partitioning strategy ('none', 'job', 'provider', 'language').
	 */
	partitioning: string;
};
type SyncDownOptions = {
	/**
	 * - If true, don't actually sync, just return stats.
	 */
	dryrun?: boolean;
	/**
	 * - Filter to specific source language.
	 */
	sourceLang?: string;
	/**
	 * - Filter to specific target language.
	 */
	targetLang?: string;
	/**
	 * - Delete local jobs not in remote store.
	 */
	deleteExtraJobs?: boolean;
	/**
	 * - Clear parent TM store assignment.
	 */
	eraseParentTmStore?: boolean;
	/**
	 * - Use alternative store ID for assignments.
	 */
	storeAlias?: string;
	/**
	 * - Number of parallel operations.
	 */
	parallelism?: number;
};
type SyncUpOptions = {
	/**
	 * - If true, don't actually sync, just return stats.
	 */
	dryrun?: boolean;
	/**
	 * - Filter to specific source language.
	 */
	sourceLang?: string;
	/**
	 * - Filter to specific target language.
	 */
	targetLang?: string;
	/**
	 * - Delete blocks with no jobs.
	 */
	deleteEmptyBlocks?: boolean;
	/**
	 * - Include jobs not assigned to any store.
	 */
	includeUnassigned?: boolean;
	/**
	 * - Assign unassigned jobs to this store.
	 */
	assignUnassigned?: boolean;
	/**
	 * - Use alternative store ID for assignments.
	 */
	storeAlias?: string;
	/**
	 * - Number of parallel operations.
	 */
	parallelism?: number;
};
type SyncDownStats = {
	/**
	 * - Source language code.
	 */
	sourceLang: string;
	/**
	 * - Target language code.
	 */
	targetLang: string;
	/**
	 * - Block IDs that need to be stored from remote.
	 */
	blocksToStore: string[];
	/**
	 * - Job GUIDs to delete locally.
	 */
	jobsToDelete: string[];
};
type SyncUpStats = {
	/**
	 * - Source language code.
	 */
	sourceLang: string;
	/**
	 * - Target language code.
	 */
	targetLang: string;
	/**
	 * - Block ID and job GUID pairs to update in remote.
	 */
	blocksToUpdate: [
		string,
		string[]
	][];
	/**
	 * - Job GUIDs to store in remote.
	 */
	jobsToUpdate: string[];
};
declare class Dispatcher {
	/**
	 * Creates a new Dispatcher instance.
	 * @param {TranslationProvider[]} providers - Array of translation providers in pipeline order.
	 */
	constructor(providers: TranslationProvider$1[]);
	/**
	 * Initializes the Dispatcher and all providers.
	 * @param {import('./index.js').MonsterManager} mm - The MonsterManager instance.
	 * @returns {Promise<void>}
	 */
	init(mm: MonsterManager$1): Promise<void>;
	/**
	 * Gets the array of configured translation providers.
	 * @returns {TranslationProvider[]} The provider pipeline.
	 */
	get providers(): TranslationProvider$1[];
	/**
	 * Gets a provider by ID (case-insensitive).
	 * @param {string} id - Provider identifier.
	 * @returns {TranslationProvider} The translation provider.
	 * @throws {Error} If the provider is not found.
	 */
	getProvider(id: string): TranslationProvider$1;
	/**
	 * Creates jobs by distributing TUs to providers in the pipeline.
	 * Each provider accepts TUs it can handle, passing remaining TUs to the next provider.
	 * @param {import('../interfaces.js').JobRequest} job - The initial job request with TUs to distribute.
	 * @param {CreateJobsOptions} [options] - Job creation options.
	 * @returns {Promise<Job[]>} Array of created jobs, one per provider that accepted TUs.
	 */
	createJobs(job: JobRequest, options?: CreateJobsOptions): Promise<Job$2[]>;
	/**
	 * Starts a batch of created jobs, sending them to their assigned providers.
	 * @param {Job[]} jobs - Array of jobs to start.
	 * @param {StartJobsOptions} options - Start options.
	 * @returns {Promise<StartedJobSummary[]>} Array of started job summaries.
	 */
	startJobs(jobs: Job$2[], options: StartJobsOptions): Promise<StartedJobSummary[]>;
	/**
	 * Updates a pending job by continuing its provider's async operation.
	 * @param {string} jobGuid - Job identifier to update.
	 * @returns {Promise<Job>} The updated job response.
	 * @throws {Error} If the job is not in pending status.
	 */
	updateJob(jobGuid: string): Promise<Job$2>;
	#private;
}
type Job$2 = Job$6;
type TranslationProvider$1 = TranslationProvider;
type CreateJobsOptions = {
	/**
	 * - List of provider IDs to try (in order).
	 */
	providerList?: string[];
	/**
	 * - Skip quality threshold checks.
	 */
	skipQualityCheck?: boolean;
	/**
	 * - Skip translation group checks.
	 */
	skipGroupCheck?: boolean;
};
type StartJobsOptions = {
	/**
	 * - Name for the job batch.
	 */
	jobName?: string;
	/**
	 * - Translation instructions for providers.
	 */
	instructions?: string;
};
type StartedJobSummary = {
	/**
	 * - Source language code.
	 */
	sourceLang: string;
	/**
	 * - Target language code.
	 */
	targetLang: string;
	/**
	 * - Job identifier.
	 */
	jobGuid: string;
	/**
	 * - Provider ID.
	 */
	translationProvider: string;
	/**
	 * - Job status.
	 */
	status: string;
	/**
	 * - Human-readable status.
	 */
	statusDescription: string;
};
/**
 * @typedef {import('../interfaces.js').TranslationProvider} TranslationProvider
 * @typedef {import('../interfaces.js').L10nAction} L10nAction
 */
/**
 * @typedef {object} L10nMonsterConfig
 * @property {object} [channels] - Channel configurations where each channel has a createChannel() method
 * @property {boolean} [autoSnap] - Whether to automatically create snapshots
 * @property {object} [snapStores] - Snap stores instances
 * @property {object} [tmStores] - TM stores instances
 * @property {object} [opsStore] - Operations store instance
 * @property {boolean} [saveFailedJobs] - Whether to save failed jobs (requires opsStore)
 * @property {TranslationProvider[]} [providers] - Array of translation providers
 * @property {object} [analyzers] - Additional analyzers to merge with default analyzers
 * @property {L10nAction[]} [actions] - Array of actions to merge with default actions
 * @property {string|boolean} [sourceDB] - Filename for the source database
 * @property {string|boolean} [tmDB] - Filename for the translation memory database
 * @property {Intl.NumberFormat} [currencyFormatter] - Custom currency formatter
 * @property {Function} [init] - Optional initialization function called during init()
 */
/**
 * @typedef {import('../interfaces.js').Analyzer} Analyzer
 */
declare class MonsterManager$1 {
	/**
 * Runs the localization process with the given global options and callback.
 * @param {L10nMonsterConfig} monsterConfig - The configuration object for the MonsterManager
 * @param {Function} cb - The callback function to execute after initialization.
 * @returns {Promise} Returns a promise that resolves with the response from the callback.
 * @throws {string} Throws an error if the localization process fails.
 */
	static run(monsterConfig: L10nMonsterConfig, cb: Function): Promise<any>;
	/**
	 * @param {L10nMonsterConfig} monsterConfig - Configuration object for the MonsterManager
	 */
	constructor(monsterConfig: L10nMonsterConfig);
	saveFailedJobs: boolean;
	/** @type {Record<string, (opts?: Record<string, unknown>) => Promise<unknown>>} */
	l10n: Record<string, (opts?: Record<string, unknown>) => Promise<unknown>>;
	/** @type {Record<string, new (...args: unknown[]) => Analyzer>} */
	analyzers: Record<string, new (...args: unknown[]) => Analyzer$1>;
	rm: ResourceManager;
	tmm: TMManager;
	dispatcher: Dispatcher;
	currencyFormatter: Intl.NumberFormat;
	init(): Promise<void>;
	/**
	 * Registers an async function to be called during shutdown.
	 * @param {() => Promise<void>} func - Async cleanup function.
	 */
	scheduleForShutdown(func: () => Promise<void>): void;
	/**
	 * Runs an analyzer on source content or translation memory.
	 * @param {string | import('../interfaces.js').Analyzer} analyzer - Analyzer name or Analyzer class.
	 * @param {string[]} [params] - Parameters passed to the analyzer constructor.
	 * @param {string} [limitToLang] - Optional language code to limit TM analysis.
	 * @returns {Promise<import('../interfaces.js').AnalysisResult>} Analysis results.
	 */
	analyze(analyzer: string | Analyzer, params?: string[], limitToLang?: string): Promise<AnalysisResult>;
	/**
	 * Gets translation status for specified channels.
	 * @param {string | string[] | undefined} [channels] - Channel ID, array of IDs, or undefined for all channels.
	 * @returns {Promise<Record<string, Record<string, Record<string, Record<string, {
	 *   translatedDetails: Array<{minQ: number; q: number; res: number; seg: number; words: number; chars: number}>;
	 *   untranslatedDetails: Record<string, Array<{minQ: number; seg: number; words: number; chars: number}>>;
	 *   pairSummary: {segs: number; words: number; chars: number};
	 *   pairSummaryByStatus: {translated: number; 'low quality': number; 'in flight': number; untranslated: number};
	 * }>>>>>} Translation status by channel/source/target/project.
	 */
	getTranslationStatus(channels?: string | string[] | undefined): Promise<Record<string, Record<string, Record<string, Record<string, {
		translatedDetails: Array<{
			minQ: number;
			q: number;
			res: number;
			seg: number;
			words: number;
			chars: number;
		}>;
		untranslatedDetails: Record<string, Array<{
			minQ: number;
			seg: number;
			words: number;
			chars: number;
		}>>;
		pairSummary: {
			segs: number;
			words: number;
			chars: number;
		};
		pairSummaryByStatus: {
			translated: number;
			"low quality": number;
			"in flight": number;
			untranslated: number;
		};
	}>>>>>;
	shutdown(): Promise<void>;
	#private;
}
type TranslationProvider$2 = TranslationProvider;
type L10nAction$1 = L10nAction;
type L10nMonsterConfig = {
	/**
	 * - Channel configurations where each channel has a createChannel() method
	 */
	channels?: object;
	/**
	 * - Whether to automatically create snapshots
	 */
	autoSnap?: boolean;
	/**
	 * - Snap stores instances
	 */
	snapStores?: object;
	/**
	 * - TM stores instances
	 */
	tmStores?: object;
	/**
	 * - Operations store instance
	 */
	opsStore?: object;
	/**
	 * - Whether to save failed jobs (requires opsStore)
	 */
	saveFailedJobs?: boolean;
	/**
	 * - Array of translation providers
	 */
	providers?: TranslationProvider$2[];
	/**
	 * - Additional analyzers to merge with default analyzers
	 */
	analyzers?: object;
	/**
	 * - Array of actions to merge with default actions
	 */
	actions?: L10nAction$1[];
	/**
	 * - Filename for the source database
	 */
	sourceDB?: string | boolean;
	/**
	 * - Filename for the translation memory database
	 */
	tmDB?: string | boolean;
	/**
	 * - Custom currency formatter
	 */
	currencyFormatter?: Intl.NumberFormat;
	/**
	 * - Optional initialization function called during init()
	 */
	init?: Function;
};
type Analyzer$1 = Analyzer;
declare class Task {
	/**
	 * Deserializes a task from a serialized operation list.
	 * @param {string} taskName - The task name.
	 * @param {SerializedOp[]} serializedOpList - Serialized operations.
	 * @returns {Task} The deserialized task.
	 */
	static deserialize(taskName: string, serializedOpList: SerializedOp$1[]): Task;
	/**
	 * Hydrates a task from the operations store.
	 * @param {OpsStoreInterface} opsStore - The operations store.
	 * @param {string} taskName - The task name to hydrate.
	 * @returns {Promise<Task>} The hydrated task.
	 */
	static hydrateFromStore(opsStore: OpsStoreInterface$1, taskName: string): Promise<Task>;
	/**
	 * Creates a new task with a root operation.
	 * @param {string} taskName - Name/ID for the task.
	 * @param {Op} rootOp - The root operation of the task.
	 */
	constructor(taskName: string, rootOp: Op);
	/** @type {string} Name/ID of this task. */
	taskName: string;
	/**
	 * Sets the operations store for persistence.
	 * @param {OpsStoreInterface} store - The operations store.
	 */
	setOpsStore(store: OpsStoreInterface$1): void;
	/**
	 * Gets the root operation of this task.
	 * @returns {Op} The root operation.
	 */
	get rootOp(): Op;
	/**
	 * Adds an operation to this task.
	 * @param {Op} op - The operation to add.
	 * @returns {Op} The added operation.
	 */
	addOp(op: Op): Op;
	/**
	 * Serializes the task to a list of serialized operations.
	 * @returns {SerializedOp[]} Array of serialized operations.
	 */
	serialize(): SerializedOp$1[];
	/**
	 * Saves the task to the operations store.
	 * @returns {Promise<void>}
	 */
	save(): Promise<void>;
	/**
	 * Executes the task by running all operations in dependency order.
	 * @param {ExecuteOptions} [options] - Execution options.
	 * @returns {Promise<unknown>} The root operation's output.
	 */
	execute(options?: ExecuteOptions): Promise<unknown>;
	#private;
}
type OpsStoreInterface$1 = OpsStoreInterface;
type SerializedOp$1 = SerializedOp;
type Op = Op$1;
type ExecuteOptions = {
	/**
	 * - Number of operations to run concurrently.
	 */
	parallelism?: number;
};
declare class Op$1 {
	/**
	 * Creates a new operation.
	 * @param {string} opName - Name of the operation.
	 * @param {OpCallback} callback - Function to execute for this operation.
	 */
	constructor(opName: string, callback: OpCallback);
	/** @type {number | undefined} Unique identifier for this operation within a task. */
	opId: number | undefined;
	/** @type {string} Name of the operation (used for registry lookup). */
	opName: string;
	/** @type {Record<string, unknown>} Arguments passed to the operation callback. */
	args: Record<string, unknown>;
	/** @type {string} Current state: 'pending', 'done', 'error', or custom blocking state. */
	state: string;
	/** @type {unknown} Output from the operation execution. */
	output: unknown;
	/** @type {string | undefined} ISO timestamp of last execution. */
	lastRanAt: string | undefined;
	/**
	 * Gets the IDs of all input dependency operations.
	 * @returns {(number | undefined)[]} Array of input operation IDs.
	 */
	get inputOpIds(): (number | undefined)[];
	/**
	 * Gets the outputs of all input dependency operations.
	 * @returns {unknown[]} Array of input operation outputs.
	 */
	get inputs(): unknown[];
	/**
	 * Gets the parent task that owns this operation.
	 * @returns {import('./task.js').default | undefined} The parent task.
	 */
	get parentTask(): Task | undefined;
	/**
	 * Sets the parent task for this operation.
	 * @param {import('./task.js').default} parentTask - The parent task.
	 */
	setParentTask(parentTask: Task): void;
	/**
	 * Adds an input dependency to this operation.
	 * @param {Op} inputOp - The operation to depend on.
	 * @returns {Op} The input operation.
	 */
	addInputDependency(inputOp: Op$1): Op$1;
	/**
	 * Creates and enqueues a new input operation as a dependency.
	 * @param {string | Function} inputOpName - Name or function of the operation.
	 * @param {Record<string, unknown>} inputOpArgs - Arguments for the new operation.
	 * @returns {Op} The newly created input operation.
	 */
	enqueue(inputOpName: string | Function, inputOpArgs: Record<string, unknown>): Op$1;
	/**
	 * Checks if this operation is ready to execute (pending with all inputs done).
	 * @returns {boolean} True if ready to execute.
	 */
	isReadyToExecute(): boolean;
	/**
	 * Executes this operation.
	 * @returns {Promise<Op>} This operation after execution.
	 */
	execute(): Promise<Op$1>;
	#private;
}
type OpCallback = (op: Op$1) => Promise<unknown>;
declare function setOpsStore(store: OpsStoreInterface$2): void;
declare function registerOp(func: Function, options?: {
	opName?: string;
	idempotent?: boolean;
	callback?: Function;
}): void;
declare function createOp(opName: string | Function, args: Record<string, unknown>): Op$1;
declare function createTask(groupName: string, rootOpName: string | Function, rootOpArgs?: Record<string, unknown>): Task;
declare function deserializeTask(taskName: string, serializedOpList: SerializedOp$2[]): Task;
declare function hydrateTaskFromStore(taskName: string): Promise<Task>;
type OpsStoreInterface$2 = OpsStoreInterface;
type SerializedOp$2 = SerializedOp;
declare class HttpSource implements SourceAdapter$2 {
	/**
	 * Creates an instance of HttpSource.
	 * @constructor
	 * @param {Object} params - The parameters for initializing the HttpSource.
	 * @param {Record<string, string>} params.urlMap - A map of resource IDs to their corresponding URLs.
	 * @param {string} params.sourceLang - The source languages for the resources.
	 * @param {string} [params.prj] - The project identifier associated with the resources.
	 * @param {Function} [params.filter] - A function to filter resources based on their IDs.
	 * @param {Function} [params.resDecorator] - A function to decorate resource metadata.
	 * @throws {string} Throws an error if `urlMap` or `sourceLang` (directly or via `resDecorator`) is not provided.
	 */
	constructor({ urlMap, sourceLang, prj, filter, resDecorator }: {
		urlMap: Record<string, string>;
		sourceLang: string;
		prj?: string;
		filter?: Function;
		resDecorator?: Function;
	});
	/** @type {Record<string, string>} */
	urlMap: Record<string, string>;
	sourceLang: string;
	prj: string;
	filter: Function;
	resDecorator: Function;
	/**
	 * Fetches all resources defined in the urlMap.
	 * Yields an array for each resource: [resourceMeta, resourceContent].
	 * The `modified` date in resourceMeta is a placeholder as HTTP servers
	 * don't reliably provide this information in a standardized way for this context.
	 * @returns {AsyncGenerator<[Object, string]>} An async generator yielding resource metadata and content.
	 */
	fetchAllResources(): AsyncGenerator<[
		any,
		string
	]>;
}
type SourceAdapter$2 = SourceAdapter;
declare class FsSource extends AbstractFsAdapter implements SourceAdapter$3 {
	static configMancerSample: {
		"@": string;
		sourceLang: string;
		globs: string[];
		$baseDir: string;
		$filter: FunctionConstructor;
		$prj: string;
		$resDecorator: FunctionConstructor;
		$idFromPath: FunctionConstructor;
	};
	/**
	 * Creates a new FsSource instance.
	 * @param {object} options - Configuration options for the source.
	 * @param {string} [options.baseDir] - Base directory for resource files.
	 * @param {string} options.sourceLang - The source language of the resources.
	 * @param {string | string[]} options.globs - glob or array of glob patterns to match resource files.
	 * @param {Function} [options.filter] - Function to filter resources based on their IDs.
	 * @param {string} [options.prj] - Project identifier for the resources.
	 * @param {Function} [options.resDecorator] - Function to decorate resource metadata.
	 * @param {Function} [options.idFromPath] - Function to derive resource ID from file path.
	 * @throws {string} Throws an error if `globs` is not provided.
	 */
	constructor({ baseDir, globs, filter, sourceLang, prj, resDecorator, idFromPath }: {
		baseDir?: string;
		sourceLang: string;
		globs: string | string[];
		filter?: Function;
		prj?: string;
		resDecorator?: Function;
		idFromPath?: Function;
	});
	globs: string[];
	filter: Function;
	sourceLang: string;
	prj: string;
	resDecorator: Function;
	idFromPath: Function;
	/**
	 * Fetches all resources matching the glob patterns.
	 * Yields an array for each resource: [resourceMeta, resourceContent].
	 * @returns {AsyncGenerator<[Object, string]>} An async generator yielding resource stat-like metadata and content.
	 */
	fetchAllResources(): AsyncGenerator<[
		any,
		string
	]>;
}
declare class FsTarget extends AbstractFsAdapter implements TargetAdapter$2 {
	static configMancerSample: {
		"@": string;
		$baseDir: string;
		$targetPath: FunctionConstructor;
		$deleteEmpty: boolean;
	};
	/**
	 * Creates a new FsTarget instance.
	 * @param {object} options - Configuration options for the target.
	 * @param {string} [options.baseDir] - Base directory for translated files.
	 * @param {Function} options.targetPath - Function to determine target path.
	 * @param {boolean} [options.deleteEmpty] - Whether to delete empty files.
	 */
	constructor({ baseDir, targetPath, deleteEmpty }: {
		baseDir?: string;
		targetPath: Function;
		deleteEmpty?: boolean;
	});
	targetPath: Function;
	deleteEmpty: boolean;
	/**
	 * Generates the path for a translated resource.
	 * @param {string} lang - The target language.
	 * @param {string} resourceId - The ID of the resource.
	 * @returns {string} The full path to the translated resource.
	 */
	translatedResourceId(lang: string, resourceId: string): string;
	/**
	 * Fetches a translated resource from the file system.
	 * @param {string} lang - The target language.
	 * @param {string} resourceId - The ID of the resource.
	 * @returns {Promise<string>} The content of the translated resource.
	 */
	fetchTranslatedResource(lang: string, resourceId: string): Promise<string>;
	/**
	 * Saves or deletes a translated resource in the file system.
	 * @param {string} lang - The target language of the translated resource.
	 * @param {string} resourceId - The ID of the resource.
	 * @param {string|null} translatedRes - The translated content
	 * If null, the file is deleted instead of written.
	 * @return {Promise<void>}
	 */
	commitTranslatedResource(lang: string, resourceId: string, translatedRes: string | null): Promise<void>;
}
type SourceAdapter$3 = SourceAdapter;
type TargetAdapter$2 = TargetAdapter;
type ChannelOptions$1 = ChannelOptions;
declare class AbstractFsAdapter {
	/**
	 * Creates a new AbstractFsAdapter instance.
	 * @param {string} [baseDir] - Base directory for resource files.
	 */
	constructor(baseDir?: string);
	/** @type {string} */
	baseDir: string;
	/**
	 * Sets channel options for this adapter.
	 * @param {ChannelOptions} options - Channel configuration options.
	 */
	setChannelOptions(options: ChannelOptions$1): void;
	#private;
}
declare class DuplicateSource implements Analyzer$2 {
	static help: string;
	/** @type {Record<string, Array<{rid: string, prj: string, sid: string, gstr: string}>>} */
	qualifiedMatches: Record<string, Array<{
		rid: string;
		prj: string;
		sid: string;
		gstr: string;
	}>>;
	/** @type {Record<string, Array<{rid: string, prj: string, sid: string, gstr: string}>>} */
	unqualifiedMatches: Record<string, Array<{
		rid: string;
		prj: string;
		sid: string;
		gstr: string;
	}>>;
	/**
	 * Process a segment during analysis.
	 * @param {{ rid: string, prj: string, seg: NormalizedSegment }} context - Segment context.
	 */
	processSegment({ rid, prj, seg }: {
		rid: string;
		prj: string;
		seg: NormalizedSegment$3;
	}): void;
	/**
	 * Get the analysis results.
	 * @returns {import('../../interfaces.js').AnalysisResult} Analysis result with headers and data rows.
	 */
	getAnalysis(): AnalysisResult;
}
type Analyzer$2 = Analyzer;
type NormalizedSegment$3 = NormalizedSegment;
declare class SmellySource implements Analyzer$3 {
	static helpParams: string;
	static help: string;
	/**
	 * @param {string} [smellyRegex] - Optional regex pattern to match.
	 */
	constructor(smellyRegex?: string);
	/** @type {Array<[string, string, string, string]>} */
	smelly: Array<[
		string,
		string,
		string,
		string
	]>;
	smellyRegex: RegExp;
	/**
	 * Process a segment during analysis.
	 * @param {{ rid: string, prj: string, seg: NormalizedSegment }} context - Segment context.
	 */
	processSegment({ rid, prj, seg }: {
		rid: string;
		prj: string;
		seg: NormalizedSegment$4;
	}): void;
	getAnalysis(): {
		head: string[];
		groupBy: string[];
		body: [
			string,
			string,
			string,
			string
		][];
	};
}
type Analyzer$3 = Analyzer;
type NormalizedSegment$4 = NormalizedSegment;
declare class TextExpansionSummary implements Analyzer$4 {
	static help: string;
	/** @type {Record<string, number[][]>} */
	langStats: Record<string, number[][]>;
	/**
	 * Process a translation unit during analysis.
	 * @param {{ targetLang: string, tu: AnalyzerTU }} context - TU context.
	 */
	processTU({ targetLang, tu }: {
		targetLang: string;
		tu: AnalyzerTU$1;
	}): void;
	getAnalysis(): {
		head: string[];
		body: string[][];
	};
}
type Analyzer$4 = Analyzer;
type AnalyzerTU$1 = AnalyzerTU;
declare class FindByExpansion implements Analyzer$5 {
	static helpParams: string;
	static help: string;
	/**
	 * @param {string | number} average - Average growth rate or path to CSV file.
	 * @param {string | number} minDelta - Minimum delta or sigma multiplier.
	 */
	constructor(average: string | number, minDelta: string | number);
	/** @type {Array<[string, string, string, string, string]>} */
	foundTus: Array<[
		string,
		string,
		string,
		string,
		string
	]>;
	average: number;
	minDelta: number;
	/** @type {Record<string, [string, string]> | undefined} */
	stats: Record<string, [
		string,
		string
	]> | undefined;
	/**
	 * Process a translation unit during analysis.
	 * @param {{ targetLang: string, tu: AnalyzerTU }} context - TU context.
	 */
	processTU({ targetLang, tu }: {
		targetLang: string;
		tu: AnalyzerTU$2;
	}): void;
	getAnalysis(): {
		head: string[];
		groupBy: string[];
		body: [
			string,
			string,
			string,
			string,
			string
		][];
	};
}
type Analyzer$5 = Analyzer;
type AnalyzerTU$2 = AnalyzerTU;
declare class MismatchedTags implements Analyzer$6 {
	static help: string;
	/** @type {Array<[string, string, string, string]>} */
	foundTus: Array<[
		string,
		string,
		string,
		string
	]>;
	/**
	 * Process a translation unit during analysis.
	 * @param {{ targetLang: string, tu: AnalyzerTU }} context - TU context.
	 */
	processTU({ targetLang, tu }: {
		targetLang: string;
		tu: AnalyzerTU$3;
	}): void;
	getAnalysis(): {
		head: string[];
		groupBy: string[];
		body: [
			string,
			string,
			string,
			string
		][];
	};
}
type Analyzer$6 = Analyzer;
type AnalyzerTU$3 = AnalyzerTU;
declare class FindInTarget implements Analyzer$7 {
	static helpParams: string;
	static help: string;
	/**
	 * @param {string} [regex] - Optional regex pattern to match.
	 */
	constructor(regex?: string);
	/** @type {Array<[string, string, string]>} */
	foundTus: Array<[
		string,
		string,
		string
	]>;
	regex: RegExp;
	/**
	 * Process a translation unit during analysis.
	 * @param {{ targetLang: string, tu: AnalyzerTU }} context - TU context.
	 */
	processTU({ targetLang, tu }: {
		targetLang: string;
		tu: AnalyzerTU$4;
	}): void;
	getAnalysis(): {
		head: string[];
		groupBy: string[];
		body: [
			string,
			string,
			string
		][];
	};
}
declare class ExportTranslationGrid implements Analyzer$7 {
	static help: string;
	/** @type {Record<string, boolean>} */
	langs: Record<string, boolean>;
	/** @type {Record<string, { source: string, [lang: string]: string }>} */
	grid: Record<string, {
		source: string;
		[lang: string]: string;
	}>;
	/**
	 * Process a translation unit during analysis.
	 * @param {{ targetLang: string, tu: AnalyzerTU }} context - TU context.
	 */
	processTU({ targetLang, tu }: {
		targetLang: string;
		tu: AnalyzerTU$4;
	}): void;
	getAggregateAnalysis(): {
		head: string[];
		groupBy: string[];
		body: string[][];
	};
}
type Analyzer$7 = Analyzer;
type AnalyzerTU$4 = AnalyzerTU;
type NormalizedString$4 = NormalizedString$1;
declare class SequenceGenerator implements SegmentDecoratorFactory$1 {
	/**
	 * Creates a new SequenceGenerator instance.
	 * @param {string} seqMapFile - Path to the sequence map file.
	 * @param {number} [seqThreshold=7] - Threshold for short string optimization.
	 */
	constructor(seqMapFile: string, seqThreshold?: number);
	/** @type {string} */
	seqMapPath: string;
	/** @type {number} */
	seqThreshold: number;
	/** @type {Record<string, number>} */
	seqMap: Record<string, number>;
	/** @type {number} */
	maxSeq: number;
	/** @type {number} */
	minSeq: number;
	/**
	 * Initializes the sequence generator and loads existing sequence map.
	 * @param {MonsterManager} mm - MonsterManager instance.
	 * @returns {Promise<void>}
	 */
	init(mm: MonsterManager$2): Promise<void>;
	/**
	 * Gets the segment decorator function.
	 * Produces at least a 2-char label and tries to assign shorter numbers to shorter strings.
	 * @returns {SegmentDecorator} The decorator function.
	 */
	getDecorator(): SegmentDecorator$2;
	/**
	 * Saves the sequence map to disk.
	 * @returns {Promise<void>}
	 */
	save(): Promise<void>;
}
type SegmentDecoratorFactory$1 = SegmentDecoratorFactory;
type SegmentDecorator$2 = SegmentDecorator;
type MonsterManager$2 = MonsterManager;
declare class MNFv1Filter implements ResourceFilter$2 {
	/** @type {{ decoders: Array<(nstr: NormalizedString) => Part[]>, codeEncoders: Array<(part: PlaceholderPart) => Part>, joiner: (parts: Part[]) => string }} */
	static normalizer: {
		decoders: Array<(nstr: NormalizedString$5) => Part$2[]>;
		codeEncoders: Array<(part: PlaceholderPart$2) => Part$2>;
		joiner: (parts: Part$2[]) => string;
	};
	/**
	 * Parses a resource string into segments.
	 * @param {{ resource: string }} params - Parse parameters.
	 * @returns {Promise<{ segments: Segment[] }>} Parsed resource with segments.
	 */
	parseResource({ resource }: {
		resource: string;
	}): Promise<{
		segments: Segment$1[];
	}>;
	/**
	 * Converts a normalized resource in the source language to raw in the target language.
	 * @param {GenerateResourceParams} params - Generation parameters.
	 * @returns {Promise<string>} Generated resource string.
	 */
	generateResource({ translator, segments, raw: _raw, ...resHandle }: GenerateResourceParams$1): Promise<string>;
}
type ResourceFilter$2 = ResourceFilter;
type NormalizedString$5 = NormalizedString$1;
type Part$2 = Part;
type PlaceholderPart$2 = PlaceholderPart;
type Segment$1 = Segment;
type GenerateResourceParams$1 = GenerateResourceParams;
declare function namedDecoder(name: string, decoder: DecoderFunction$2): DecoderFunction$2;
declare function gatedEncoder(encoder: TextEncoderFunction$3, ...flagNames: string[]): TextEncoderFunction$3;
declare function keywordTranslatorMaker(name: string, keywordToTranslationMap: Record<string, string | Record<string, string>>): [
	DecoderFunction$2,
	TextEncoderFunction$3
];
declare function defaultCodeEncoder(part: PlaceholderPart$5 | string): string;
declare function defaultTextEncoder(text: string): string;
declare const doublePercentDecoder: DecoderFunction;
declare const doublePercentEncoder: TextEncoderFunction;
declare const bracePHDecoder: DecoderFunction;
type Part$3 = Part$6;
type DecoderFunction$2 = DecoderFunction$4;
type EncodeFlags$2 = EncodeFlags$4;
declare function fixedTargets(targetLangs: string | string[], minimumQuality: number): TranslationPolicy$3;
declare function byProject(prjToPipelineMap: Record<string, TranslationPolicy$3[]>): TranslationPolicy$3;
declare function minimizePluralForms(): TranslationPolicy$3;
type TranslationPlan$2 = TranslationPlan$3;
type TranslationPolicy$3 = TranslationPolicy$5;
type PolicyContext$1 = PolicyContext$2;
declare class BaseTranslationProvider implements TranslationProvider$3 {
	/**
	 * Initializes a new instance of the BaseTranslationProvider class.
	 * @param {BaseTranslationProviderOptions} [options] - Configuration options for the provider.
	 */
	constructor({ id, quality, supportedPairs, translationGroup, translationGroups, defaultInstructions, minWordQuota, maxWordQuota, costPerWord, costPerMChar, saveIdenticalEntries, parallelism }?: BaseTranslationProviderOptions);
	defaultInstructions: string;
	quality: number;
	translationGroups: Set<string>;
	costPerWord: number;
	costPerMChar: number;
	minWordQuota: number;
	maxWordQuota: number;
	saveIdenticalEntries: boolean;
	supportedPairs: Record<string, string[]>;
	/** @type {StatusProperties} */
	statusProperties: StatusProperties$1;
	get id(): string;
	/**
	 * Creates a job from a job request.
	 * @param {Job} job - Job request to process.
	 * @param {{ skipQualityCheck?: boolean, skipGroupCheck?: boolean }} [options] - Optional creation options.
	 * @returns {Promise<Job>} Created job with status and metadata.
	 */
	create(job: Job$3, options?: {
		skipQualityCheck?: boolean;
		skipGroupCheck?: boolean;
	}): Promise<Job$3>;
	/**
	 * Starts a created job (execute translation).
	 * @param {Job} job - Job to start.
	 * @returns {Promise<Job>} Job with updated status and translations.
	 */
	start(job: Job$3): Promise<Job$3>;
	/**
	 * Continues a pending job (for async providers).
	 * @param {Job} job - Job to continue.
	 * @returns {Promise<Job>} Job with updated status.
	 */
	continue(job: Job$3): Promise<Job$3>;
	/**
	 * Gets provider information.
	 * @returns {Promise<{ id: string, type: string, quality?: number, supportedPairs?: Record<string, string[]>, costPerWord?: number, costPerMChar?: number, description: string[] }>} Provider metadata.
	 */
	info(): Promise<{
		id: string;
		type: string;
		quality?: number;
		supportedPairs?: Record<string, string[]>;
		costPerWord?: number;
		costPerMChar?: number;
		description: string[];
	}>;
	/**
	 * Initializes the provider with MonsterManager.
	 * @param {MonsterManager} mm - MonsterManager instance.
	 * @returns {Promise<void>}
	 */
	init(mm: MonsterManager$3): Promise<void>;
	mm: MonsterManager;
	/**
	 * Get the list of TUs accepted by the provider.
	 * Override this method to filter which TUs to accept.
	 * @param {Job} job - The job request.
	 * @returns {Promise<TU[]>} A promise resolving to an array of accepted TUs.
	 */
	getAcceptedTus(job: Job$3): Promise<TU$3[]>;
	/**
	 * Get the translated TUs.
	 * Override this method for synchronous translation.
	 * @param {Job} job - The job request.
	 * @returns {Promise<TU[]>} The array of translated TUs.
	 */
	getTranslatedTus(job: Job$3): Promise<TU$3[]>;
	/**
	 * Creates a task that when executed will return the job response.
	 * Override this method for async/resumable translation.
	 * @param {Job} job - The job request.
	 * @returns {import('../../opsManager/task.js').default} The task to execute.
	 */
	createTask(job: Job$3): Task;
	#private;
}
type TranslationProvider$3 = TranslationProvider;
type Job$3 = Job;
type TU$3 = TU$1;
type StatusProperties$1 = StatusProperties;
type MonsterManager$3 = MonsterManager;
type BaseTranslationProviderOptions = {
	/**
	 * - Global identifier for the provider. Optional.
	 */
	id?: string;
	/**
	 * - The quality of translations provided by the provider. Optional.
	 */
	quality?: number;
	/**
	 * - Supported pairs for the provider. Optional. (e.g., { "en-US": ["de-DE", "es-ES"] })
	 */
	supportedPairs?: Record<string, string[]>;
	/**
	 * - If defined, only accept jobs with the same "group" property. Optional.
	 */
	translationGroup?: string;
	/**
	 * - If defined, only accept jobs with a "group" property matching one of these values. Can be an array or a comma-separated string. Optional.
	 */
	translationGroups?: string[] | string;
	/**
	 * - Instructions to include automatically in job.
	 */
	defaultInstructions?: string;
	/**
	 * - Minimum word quota to accept the job. Optional.
	 */
	minWordQuota?: number;
	/**
	 * - Maximum word quota to accept the job. Optional.
	 */
	maxWordQuota?: number;
	/**
	 * - The estimated cost per word for the provider. Optional.
	 */
	costPerWord?: number;
	/**
	 * - The estimated cost per million characters for the provider. Optional.
	 */
	costPerMChar?: number;
	/**
	 * - Save translations even if identical to TM. Optional.
	 */
	saveIdenticalEntries?: boolean;
	/**
	 * - Number of operations to run concurrently when executing tasks. Optional.
	 */
	parallelism?: number;
};
declare class ChunkedRemoteTranslationProvider extends BaseTranslationProvider {
	/**
	 * Initializes a new instance of the ChunkedRemoteTranslationProvider class.
	 * @param {ChunkedRemoteTranslationProviderOptions} options - Configuration options for the provider.
	 */
	constructor({ maxCharLength, maxChunkSize, languageMapper, includeTranslations, ...options }: ChunkedRemoteTranslationProviderOptions);
	maxCharLength: number;
	maxChunkSize: number;
	includeTranslations: boolean;
	/**
	 * Prepares chunk arguments for translation. Override to add provider-specific properties.
	 * @param {TranslateChunkArgs} chunkArgs - Base chunk arguments.
	 * @returns {ProviderTranslateChunkArgs} Provider-specific chunk arguments.
	 */
	prepareTranslateChunkArgs(chunkArgs: TranslateChunkArgs$1): ProviderTranslateChunkArgs$1;
	/**
	 * Operation handler for translating a single chunk.
	 * @param {Op} op - The operation with args containing tuMeta and provider-specific args.
	 * @returns {Promise<TranslateChunkOpResult>} Result with raw response and normalized translations.
	 */
	startTranslateChunkOp(op: Op$2): Promise<TranslateChunkOpResult$1>;
	/**
	 * Provider-specific method to translate a chunk of TUs.
	 * Must be implemented by subclasses.
	 * @param {ProviderTranslateChunkArgs} args - Provider-specific arguments from prepareTranslateChunkArgs.
	 * @returns {Promise<ProviderResponseChunk>} Raw response from the translation API.
	 */
	startTranslateChunk(args: ProviderTranslateChunkArgs$1): Promise<ProviderResponseChunk$1>;
	/**
	 * Converts the raw translation response into a standard format.
	 * Must be implemented by subclasses.
	 * @param {ProviderResponseChunk} chunk - The raw response from startTranslateChunk.
	 * @returns {TranslatedChunk[]} Array of normalized translation results.
	 */
	convertTranslationResponse(chunk: ProviderResponseChunk$1): TranslatedChunk$1[];
	/**
	 * Operation handler that merges translated chunks into the final job response.
	 * @param {Op} op - The operation with inputs from all chunk translations.
	 * @returns {Promise<Job>} The completed job with merged translations.
	 */
	mergeTranslatedChunksOp(op: Op$2): Promise<Job$4>;
	/**
	 * Operation handler for continuing/fetching a pending chunk translation.
	 * Override in subclasses that support async continuation.
	 * @param {Op} op - The operation context containing fetch parameters.
	 * @returns {Promise<TranslateChunkOpResult>} Result with raw response and normalized translations.
	 */
	continueTranslateChunkOp(op: Op$2): Promise<TranslateChunkOpResult$1>;
	#private;
}
type Job$4 = Job;
type TranslateChunkArgs$1 = TranslateChunkArgs;
type ProviderTranslateChunkArgs$1 = ProviderTranslateChunkArgs;
type ProviderResponseChunk$1 = ProviderResponseChunk;
type TranslatedChunk$1 = TranslatedChunk;
type TranslateChunkOpResult$1 = TranslateChunkOpResult;
type Op$2 = Op$1;
type ChunkedRemoteTranslationProviderOptions = {
	/**
	 * - Global identifier for the provider.
	 */
	id?: string;
	/**
	 * - Supported language pairs for the provider.
	 */
	supportedPairs?: Record<string, string[]>;
	/**
	 * - The estimated cost per word for the provider.
	 */
	costPerWord?: number;
	/**
	 * - The estimated cost per million characters for the provider.
	 */
	costPerMChar?: number;
	/**
	 * - The quality score (e.g., 0-100) to assign to translations generated by this provider. This is required.
	 */
	quality: number;
	/**
	 * - Maximum total characters allowed in a single API request chunk. Defaults to 9900 if not provided.
	 */
	maxCharLength?: number;
	/**
	 * - Maximum number of text segments (strings) allowed in a single API request chunk. Defaults to 125 if not provided.
	 */
	maxChunkSize?: number;
	/**
	 * - An optional function to map standard language codes
	 * (e.g., 'en-US') to provider-specific codes if needed. Receives a standard language code and should return the
	 * provider-specific code. If omitted, language codes are used as-is.
	 */
	languageMapper?: (languageCode: string) => string;
	/**
	 * - When true and a previous translation (ntgt) exists on a TU, include it in the xmlTu as a 'translation' property.
	 */
	includeTranslations?: boolean;
};
declare class LLMTranslationProvider extends ChunkedRemoteTranslationProvider {
	/**
	 * Initializes a new instance of the LLMTranslationProvider class.
	 * @param {LLMTranslationProviderOptions} options - Configuration options for the provider.
	 */
	constructor({ model, temperature, persona, customSchema, maxRetries, sleepBasePeriod, targetLangInstructions, ...options }: LLMTranslationProviderOptions);
	model: string;
	temperature: number;
	systemPrompt: string;
	customSchema: import("zod").ZodTypeAny;
	maxRetries: number;
	sleepBasePeriod: number;
	targetLangInstructions: {};
	/**
	 * Builds the user prompt for translation requests.
	 * @param {object} options - Options for building the prompt
	 * @param {string} options.sourceLang - Source language
	 * @param {string} options.targetLang - Target language
	 * @param {XmlTu[]} options.xmlTus - Translation units in XML format
	 * @param {string} [options.instructions] - Additional job instructions
	 * @returns {string} The constructed user prompt
	 */
	buildUserPrompt({ sourceLang, targetLang, xmlTus, instructions }: {
		sourceLang: string;
		targetLang: string;
		xmlTus: XmlTu$1[];
		instructions?: string;
	}): string;
	/**
	 * Lazy initialization method that must be implemented by subclasses.
	 * This should initialize the LLM client on first use.
	 * @abstract
	 * @returns {Promise<void>}
	 */
	lazyInit(): Promise<void>;
	/**
	 * Provider-specific method to generate content from the LLM.
	 * This should make the actual API call to the LLM service.
	 * @abstract
	 * @param {ProviderTranslateChunkArgs} args - The provider-specific arguments for the LLM call.
	 * @returns {Promise<ProviderResponseChunk>} The raw response from the LLM.
	 */
	generateContent(args: ProviderTranslateChunkArgs$2): Promise<ProviderResponseChunk$2>;
	/**
	 * Determines whether to retry a failed request based on the error status.
	 * @param {Error & { status?: number }} error - The error from the LLM call.
	 * @returns {boolean} True if the request should be retried.
	 */
	shouldRetry(error: Error & {
		status?: number;
	}): boolean;
	/**
	 * Processes a translation object to extract the target text.
	 * For custom schemas, returns JSON stringified object.
	 * For default schema, returns the translation field.
	 * @param {object} translationObj - The translation object from the LLM response
	 * @returns {string} The target translation text
	 */
	extractTargetText(translationObj: object): string;
	/**
	 * Processes translation objects to create standard translation units.
	 * @param {Record<string, { translation?: string, confidence?: number, tnotes?: string, notes?: string }> | Array<{ translation?: string, confidence?: number, tnotes?: string, notes?: string }>} translations - Object or array of translation results.
	 * @param {number | number[]} cost - Cost per translation (number or array for detailed token breakdown).
	 * @returns {TranslatedChunk[]} Array of processed translation units.
	 */
	processTranslations(translations: Record<string, {
		translation?: string;
		confidence?: number;
		tnotes?: string;
		notes?: string;
	}> | Array<{
		translation?: string;
		confidence?: number;
		tnotes?: string;
		notes?: string;
	}>, cost: number | number[]): TranslatedChunk$2[];
}
type ProviderTranslateChunkArgs$2 = ProviderTranslateChunkArgs;
type ProviderResponseChunk$2 = ProviderResponseChunk;
type TranslatedChunk$2 = TranslatedChunk;
type XmlTu$1 = XmlTu;
type LLMTranslationProviderOptions = ChunkedRemoteTranslationProviderOptions & {
	model: string;
	temperature?: number;
	persona?: string;
	targetLangInstructions?: {
		[x: string]: string;
	};
	customSchema?: import("zod").ZodTypeAny;
	maxRetries?: number;
	sleepBasePeriod?: number;
};
declare class Grandfather extends BaseTranslationProvider {
	/**
	 * Initializes a new instance of the Grandfather class.
	 * @param {Object} options - The parameters for the constructor.
	 * @param {string} [options.id] - Global identifier for the provider.
	 * @param {Record<string, string[]>} [options.supportedPairs] - Supported pairs for the provider.
	 * @param {number} options.quality - The quality to assign grandfathered translations.
	 */
	constructor(options: {
		id?: string;
		supportedPairs?: Record<string, string[]>;
		quality: number;
	});
}
declare class Repetition extends BaseTranslationProvider {
	/**
	 * Initializes a new instance of the Repetition class.
	 * @param {Object} options - The parameters for the constructor.
	 * @param {string} [options.id] - Global identifier for the provider.
	 * @param {Record<string, string[]>} [options.supportedPairs] - Supported pairs for the provider.
	 * @param {number} [options.qualifiedPenalty] - Penalty for qualified matches.
	 * @param {number} [options.unqualifiedPenalty] - Penalty for unqualified matches.
	 * @param {number} [options.notesMismatchPenalty] - Penalty for notes mismatch.
	 * @param {number} [options.groupPenalty] - Penalty for group mismatch.
	 * @param {boolean} [options.holdInternalLeverage] - Whether to hold back internal repetitions.
	 * @param {number} [options.expectedQuality] - Expected quality of translations (required when holdInternalLeverage is true).
	 */
	constructor({ qualifiedPenalty, unqualifiedPenalty, notesMismatchPenalty, groupPenalty, holdInternalLeverage, expectedQuality, ...options }: {
		id?: string;
		supportedPairs?: Record<string, string[]>;
		qualifiedPenalty?: number;
		unqualifiedPenalty?: number;
		notesMismatchPenalty?: number;
		groupPenalty?: number;
		holdInternalLeverage?: boolean;
		expectedQuality?: number;
	});
	qualifiedPenalty: number;
	unqualifiedPenalty: number;
	notesMismatchPenalty: number;
	groupPenalty: number;
	holdInternalLeverage: boolean;
	expectedQuality: number;
	#private;
}
declare class InternalLeverageHoldout extends BaseTranslationProvider {
	/**
	 * Initializes a new instance of the InternalLeverageHoldout class.
	 * @param {Object} [options] - The parameters for the constructor.
	 * @param {string} [options.id] - Global identifier for the provider.
	 * @param {Record<string, string[]>} [options.supportedPairs] - Supported pairs for the provider.
	 * @deprecated Use Repetition provider with holdInternalLeverage: true instead.
	 */
	constructor(options?: {
		id?: string;
		supportedPairs?: Record<string, string[]>;
	});
	/**
	 * Returns empty array to release held TUs.
	 * @returns {Promise<TUType[]>} Empty array.
	 */
	getTranslatedTus(): Promise<TUType[]>;
}
type TUType = TU$1;
declare class Visicode extends BaseTranslationProvider {
	/**
	 * Initializes a new instance of the Visicode class.
	 * @param {Object} options - The parameters for the constructor.
	 * @param {string} [options.id] - Global identifier for the provider.
	 * @param {Record<string, string[]>} [options.supportedPairs] - Supported pairs for the provider.
	 * @param {number} options.quality - The quality to assign translations.
	 */
	constructor(options: {
		id?: string;
		supportedPairs?: Record<string, string[]>;
		quality: number;
	});
}
declare class LanguageVariantProvider extends BaseTranslationProvider {
	/**
	 * Initializes a new instance of the LanguageVariantProvider class.
	 * @param {LanguageVariantProviderOptions} options - The parameters for the constructor.
	 */
	constructor({ dict, baseLang, ...options }: LanguageVariantProviderOptions);
	#private;
}
type LanguageVariantProviderOptions = BaseTranslationProviderOptions & {
	baseLang: string;
	dict: {
		[x: string]: string;
	};
};
declare class InvisicodeProvider extends BaseTranslationProvider {
	/**
	 * @param {InvisicodeProviderOptions} options - The parameters for the constructor.
	 * @throws {Error} if quality, lowQ or highQ are not specified
	 */
	constructor({ baseLang, fallback, includeQ, ...options }: InvisicodeProviderOptions);
	#private;
}
type InvisicodeProviderOptions = BaseTranslationProviderOptions & {
	baseLang?: string | ((lang: string) => string);
	fallback?: boolean;
	includeQ?: boolean;
};
declare function decoderMaker(flag: string, regex: RegExp, partDecoder: (groups: Record<string, string>) => string | PlaceholderPart$3 | Part$4[]): DecoderFunction$3;
declare function encoderMaker(name: string, regex: RegExp, matchMap: Record<string, string> | ((match: string, flags: EncodeFlags$3, ...captures: string[]) => string)): TextEncoderFunction$2;
type Part$4 = Part$6;
type PlaceholderPart$3 = PlaceholderPart$5;
type DecoderFunction$3 = DecoderFunction$4;
type TextEncoderFunction$2 = TextEncoderFunction$3;
type EncodeFlags$3 = EncodeFlags$4;
declare class BaseJsonlTmStore implements TMStore$2 {
	/**
	 * Creates a BaseJsonlTmStore instance
	 * @param {_FileStoreDelegate} delegate - Required file store delegate implementing file operations
	 * @param {Object} options - Base store options
	 * @param {string} options.id - The logical id of the instance
	 * @param {'readwrite' | 'readonly' | 'writeonly'} [options.access] - The store access permissions
	 * @param {'job' | 'provider' | 'language'} [options.partitioning] - Partitioning strategy for TM Blocks
	 * @param {boolean} [options.compressBlocks] - Use Gzip compression
	 * @throws {Error} If no delegate is provided or invalid partitioning is specified
	 */
	constructor(delegate: _FileStoreDelegate, { id, partitioning, access, compressBlocks }: {
		id: string;
		access?: "readwrite" | "readonly" | "writeonly";
		partitioning?: "job" | "provider" | "language";
		compressBlocks?: boolean;
	});
	id: string;
	/** @type {'readwrite' | 'readonly' | 'writeonly'} */
	access: "readwrite" | "readonly" | "writeonly";
	/** @type {'job' | 'provider' | 'language'} */
	partitioning: "job" | "provider" | "language";
	/** @type {_FileStoreDelegate} */
	delegate: _FileStoreDelegate;
	/**
	 * Gets available language pairs in the store.
	 * @returns {Promise<Array<[string, string]>>} Array of [sourceLang, targetLang] tuples.
	 */
	getAvailableLangPairs(): Promise<Array<[
		string,
		string
	]>>;
	/**
	 * Gets TM blocks by their IDs.
	 * @param {string} sourceLang - Source language code.
	 * @param {string} targetLang - Target language code.
	 * @param {string[]} blockIds - Array of block IDs to retrieve.
	 * @returns {AsyncGenerator<JobPropsTusPair>} AsyncGenerator yielding job objects with TUs.
	 */
	getTmBlocks(sourceLang: string, targetLang: string, blockIds: string[]): AsyncGenerator<JobPropsTusPair$3>;
	/**
	 * Gets the table of contents for a language pair.
	 * @param {string} sourceLang - Source language code.
	 * @param {string} targetLang - Target language code.
	 * @returns {Promise<TMStoreTOC>} TOC object with block metadata.
	 */
	getTOC(sourceLang: string, targetLang: string): Promise<TMStoreTOC$1>;
	/**
	 * Gets a writer for committing TM data.
	 * @param {string} sourceLang - Source language code.
	 * @param {string} targetLang - Target language code.
	 * @param {Function} cb - Callback function for writing blocks.
	 * @returns {Promise<void>}
	 */
	getWriter(sourceLang: string, targetLang: string, cb: Function): Promise<void>;
	#private;
}
type TMStore$2 = TMStore;
type TMStoreTOC$1 = TMStoreTOC;
type JobPropsTusPair$3 = JobPropsTusPair;
type _FileStoreDelegate = FileStoreDelegate;
declare class LegacyFileBasedTmStore implements _TMStore {
	/**
	 * Creates a LegacyFileBasedTmStore instance
	 * @param {Object} options - Configuration options
	 * @param {_FileStoreDelegate} options.delegate - Required file store delegate implementing file operations
	 * @param {string} options.id - Required unique identifier for the store
	 * @param {number} [options.parallelism=1] - Number of blocks to fetch in parallel
	 * @throws {Error} If no delegate or id is provided
	 */
	constructor(options: {
		delegate: _FileStoreDelegate$1;
		id: string;
		parallelism?: number;
	});
	/** @type {string} */
	id: string;
	/** @type {number} */
	parallelism: number;
	/** @type {_FileStoreDelegate} */
	delegate: _FileStoreDelegate$1;
	/** @type {'readonly'} */
	get access(): "readonly";
	/** @type {'job'} */
	get partitioning(): "job";
	/**
	 * Gets available language pairs in the store.
	 * @returns {Promise<Array<[string, string]>>} Array of [sourceLang, targetLang] tuples.
	 */
	getAvailableLangPairs(): Promise<Array<[
		string,
		string
	]>>;
	/**
	 * Lists all TM blocks for a language pair.
	 * @param {string} sourceLang - Source language code.
	 * @param {string} targetLang - Target language code.
	 * @returns {Promise<Array<[string, string]>>} Array of [blockName, modified] tuples.
	 */
	listAllTmBlocks(sourceLang: string, targetLang: string): Promise<Array<[
		string,
		string
	]>>;
	/**
	 * Gets TM blocks by their IDs.
	 * @param {string} sourceLang - Source language code.
	 * @param {string} targetLang - Target language code.
	 * @param {string[]} blockIds - Array of block IDs to retrieve.
	 * @returns {AsyncGenerator<JobPropsTusPair>} AsyncGenerator yielding job objects with TUs.
	 */
	getTmBlocks(sourceLang: string, targetLang: string, blockIds: string[]): AsyncGenerator<JobPropsTusPair$4>;
	/**
	 * Gets the table of contents for a language pair.
	 * @param {string} sourceLang - Source language code.
	 * @param {string} targetLang - Target language code.
	 * @returns {Promise<TMStoreTOC>} TOC object with block metadata.
	 */
	getTOC(sourceLang: string, targetLang: string): Promise<TMStoreTOC$2>;
	getWriter(): Promise<void>;
	#private;
}
type _TMStore = TMStore;
type _FileStoreDelegate$1 = FileStoreDelegate;
type TMStoreTOC$2 = TMStoreTOC;
type JobPropsTusPair$4 = JobPropsTusPair;
declare class FsStoreDelegate implements FileStoreDelegate$1 {
	/**
	 * Creates a new FsStoreDelegate instance.
	 * @param {string} baseDir - Base directory for file operations.
	 */
	constructor(baseDir: string);
	/** @type {string} */
	baseDir: string;
	toString(): string;
	/**
	 * Lists all files in the base directory.
	 * @returns {Promise<Array<[string, string]>>} Array of [filename, timestamp] tuples.
	 */
	listAllFiles(): Promise<Array<[
		string,
		string
	]>>;
	/**
	 * Ensures the base directory exists.
	 * @returns {Promise<string | undefined>} The created directory path or undefined.
	 */
	ensureBaseDirExists(): Promise<string | undefined>;
	/**
	 * Gets file contents as a string.
	 * @param {string} filename - File path relative to base directory.
	 * @returns {Promise<string>} File contents.
	 */
	getFile(filename: string): Promise<string>;
	/**
	 * Gets a readable stream for a file.
	 * @param {string} filename - File path relative to base directory.
	 * @returns {import('node:fs').ReadStream} Readable stream.
	 */
	getStream(filename: string): import("node:fs").ReadStream;
	/**
	 * Saves content to a file.
	 * @param {string | string[]} filename - File path or path segments.
	 * @param {string} contents - Content to write.
	 * @returns {Promise<string>} Timestamp string for the saved file.
	 */
	saveFile(filename: string | string[], contents: string): Promise<string>;
	/**
	 * Saves a readable stream to a file.
	 * @param {string | string[]} filename - File path or path segments.
	 * @param {NodeJS.ReadableStream} readable - Readable stream to save.
	 * @param {boolean} [deleteEmptyFiles=false] - Whether to delete if file is empty.
	 * @returns {Promise<string | null>} Timestamp string or null if deleted.
	 */
	saveStream(filename: string | string[], readable: NodeJS.ReadableStream, deleteEmptyFiles?: boolean): Promise<string | null>;
	/**
	 * Deletes multiple files.
	 * @param {string[]} filenames - Array of file paths to delete.
	 * @returns {Promise<void>}
	 */
	deleteFiles(filenames: string[]): Promise<void>;
}
type FileStoreDelegate$1 = FileStoreDelegate;
declare class BaseFileBasedSnapStore implements SnapStore$1 {
	/**
	 * Creates a BaseFileBasedSnapStore instance
	 * @param {_FileStoreDelegate} delegate - Required file store delegate implementing file operations
	 * @param {Object} options - Base store options
	 * @param {string} options.id - The logical id of the instance
	 * @param {'jsonl' | 'gzip'} options.format - The format of the snap files
	 * @throws {Error} If no delegate is provided
	 */
	constructor(delegate: _FileStoreDelegate$2, options: {
		id: string;
		format: "jsonl" | "gzip";
	});
	id: string;
	/** @type {_FileStoreDelegate} */
	delegate: _FileStoreDelegate$2;
	/**
	 * Gets the table of contents listing all snapshots.
	 * @returns {Promise<Record<string, number[]>>} Object mapping channel IDs to arrays of timestamps.
	 */
	getTOC(): Promise<Record<string, number[]>>;
	/**
	 * Generates rows from a snapshot.
	 * @param {number} ts - Snapshot timestamp.
	 * @param {string} channelId - Channel identifier.
	 * @param {string} table - Table name ('segments' or 'resources').
	 * @returns {AsyncGenerator<Record<string, unknown>>} AsyncGenerator yielding row objects.
	 */
	generateRows(ts: number, channelId: string, table: string): AsyncGenerator<Record<string, unknown>>;
	/**
	 * Saves a snapshot from a row generator.
	 * @param {number} ts - Snapshot timestamp.
	 * @param {string} channelId - Channel identifier.
	 * @param {AsyncGenerator<Record<string, unknown>>} rowGenerator - AsyncGenerator providing rows to save.
	 * @param {string} table - Table name ('segments' or 'resources').
	 * @returns {Promise<{ count: number }>} Stats object with count of saved rows.
	 */
	saveSnap(ts: number, channelId: string, rowGenerator: AsyncGenerator<Record<string, unknown>>, table: string): Promise<{
		count: number;
	}>;
	#private;
}
type SnapStore$1 = SnapStore;
type _FileStoreDelegate$2 = FileStoreDelegate;
declare class FsLegacyJsonTmStore extends LegacyFileBasedTmStore {
	/**
	 * Creates an FsLegacyJsonTmStore instance.
	 * @param {Object} options - Configuration options.
	 * @param {string} options.jobsDir - Directory path for jobs storage.
	 * @param {string} options.id - Unique identifier for the store.
	 * @param {number} [options.parallelism] - Number of blocks to fetch in parallel.
	 */
	constructor({ jobsDir, id, parallelism }: {
		jobsDir: string;
		id: string;
		parallelism?: number;
	});
}
declare class FsJsonlTmStore extends BaseJsonlTmStore {
	/**
	 * Creates an FsJsonlTmStore instance.
	 * @param {Object} options - Configuration options.
	 * @param {string} options.jobsDir - Directory path for jobs storage.
	 * @param {string} options.id - The logical id of the instance.
	 * @param {'readwrite' | 'readonly' | 'writeonly'} [options.access] - Store access permissions.
	 * @param {'job' | 'provider' | 'language'} [options.partitioning] - Partitioning strategy.
	 * @param {boolean} [options.compressBlocks] - Use Gzip compression.
	 */
	constructor(options: {
		jobsDir: string;
		id: string;
		access?: "readwrite" | "readonly" | "writeonly";
		partitioning?: "job" | "provider" | "language";
		compressBlocks?: boolean;
	});
}
declare class OpsStore implements OpsStoreInterface$3 {
	/**
	 * Creates an OpsStore instance.
	 * @param {_FileStoreDelegate} storeDelegate - File store delegate for storage operations.
	 */
	constructor(storeDelegate: _FileStoreDelegate$3);
	/**
	 * Saves operations for a task.
	 * @param {string} taskName - Name/ID of the task.
	 * @param {SerializedOp[]} opList - List of serialized operations to save.
	 * @returns {Promise<void>}
	 */
	saveOps(taskName: string, opList: SerializedOp$3[]): Promise<void>;
	/**
	 * Gets operations for a task.
	 * @param {string} taskName - Name/ID of the task.
	 * @returns {AsyncGenerator<SerializedOp>} Async generator of serialized operation objects.
	 */
	getTask(taskName: string): AsyncGenerator<SerializedOp$3>;
	#private;
}
declare class FsOpsStore extends OpsStore {
	/**
	 * Creates an FsOpsStore instance.
	 * @param {string} opsDir - Directory path for storing operations.
	 */
	constructor(opsDir: string);
}
type OpsStoreInterface$3 = OpsStoreInterface;
type _FileStoreDelegate$3 = FileStoreDelegate;
type SerializedOp$3 = SerializedOp;
declare function generateGuid(str: string): string;
declare function consolidateDecodedParts(parts: Part$5[], flags: EncodeFlags, convertToString?: boolean): Part$5[];
declare function decodeNormalizedString(nstr: Part$5[], decoderList: DecoderFunction$4[], flags?: EncodeFlags): NormalizedString$6;
declare function getNormalizedString(str: string, decoderList: DecoderFunction$4[], flags?: EncodeFlags): NormalizedString$6;
declare function flattenNormalizedSourceToOrdinal(nsrc: NormalizedString$6): string;
declare function flattenNormalizedSourceV1(nsrc: NormalizedString$6): [
	string,
	PlaceholderMap
];
declare function extractNormalizedPartsV1(str: string, phMap: PlaceholderMap): NormalizedString$6;
declare function flattenNormalizedSourceToXmlV1(nsrc: NormalizedString$6): [
	string,
	PlaceholderMap
];
declare function extractNormalizedPartsFromXmlV1(str: string, phMap: PlaceholderMap): NormalizedString$6;
declare function phMatcherMaker(nsrc: NormalizedString$6): (arg0: PlaceholderPart$4) => PlaceholderPart$4 | undefined;
declare function sourceAndTargetAreCompatible(nsrc: NormalizedString$6, ntgt: NormalizedString$6): boolean;
declare function normalizedStringsAreEqual(s1: NormalizedString$6, s2: NormalizedString$6): boolean;
declare function getTUMaps(tus: TU[]): TUMaps;
declare function extractStructuredNotes(notes: string): StructuredNotes$2;
declare function integerToLabel(int: number): string;
declare function fixCaseInsensitiveKey(object: Record<string, unknown>, key: string): string | undefined;
declare function getIteratorFromJobPair(jobRequest?: Job$5, jobResponse?: Job$5): Generator<{
	jobProps: JobProps$2;
	tus: TU[];
}, void, unknown>;
declare function validate(context: any, obj?: {}): {
	objectProperty: (...props: any[]) => any;
	arrayOfFunctions: (...props: any[]) => any;
};
declare function balancedSplitWithObjects(items: object[], n: number, weightProperty: string): object[][];
type NormalizedString$6 = NormalizedString$7;
type Part$5 = Part$6;
type PlaceholderPart$4 = PlaceholderPart$5;
type JobProps$2 = JobProps$3;
type Job$5 = Job$6;
type StructuredNotes$2 = StructuredNotes$3;
type PlaceholderMap = {
	[x: string]: PlaceholderPart;
};
type TUMaps = {
	/**
	 * - Map of GUID to flattened source string.
	 */
	contentMap: {
		[x: string]: string;
	};
	/**
	 * - Map of GUID to placeholder metadata.
	 */
	tuMeta: {
		[x: string]: any;
	};
	/**
	 * - Map of GUID to formatted placeholder notes.
	 */
	phNotes: {
		[x: string]: string;
	};
};
declare const entityDecoder: DecoderFunction;
declare const CDataDecoder: DecoderFunction;
declare const entityEncoder: TextEncoderFunction;
declare const tagDecoder: DecoderFunction;
declare const analyze: L10nAction$3;
declare const ops: L10nAction$3;
declare const monster: L10nAction$3;
declare const source: L10nAction$3;
declare const tm: L10nAction$3;
declare const translate: L10nAction$3;
export function getVerbosity(): number;
export function setVerbosity(level: number): void;
export function getRegressionMode(): boolean;
export function setRegressionMode(mode: boolean): void;
export function getBaseDir(): string;
export function setBaseDir(dir: string): void;
export function logError(strings: TemplateStringsArray, ...values: unknown[]): void;
export function logWarn(strings: TemplateStringsArray, ...values: unknown[]): void;
export function logInfo(strings: TemplateStringsArray, ...values: unknown[]): void;
export function logVerbose(strings: TemplateStringsArray, ...values: unknown[]): void;
export function consoleLog(strings: TemplateStringsArray, ...values: unknown[]): void;
export function styleString(strings: TemplateStringsArray, ...values: unknown[]): string;
/**
 * @typedef {import('./interfaces.js').ResourceFilter} ResourceFilter
 * @typedef {import('./interfaces.js').ResourceGenerator} ResourceGenerator
 * @typedef {import('./interfaces.js').SourceAdapter} SourceAdapter
 * @typedef {import('./interfaces.js').TargetAdapter} TargetAdapter
 * @typedef {import('./interfaces.js').TMStore} TMStore
 * @typedef {import('./interfaces.js').SnapStore} SnapStore
 * @typedef {import('./interfaces.js').TranslationProvider} TranslationProvider
 * @typedef {import('./interfaces.js').TranslationPolicy} TranslationPolicy
 * @typedef {import('./interfaces.js').OpsStoreInterface} OpsStoreInterface
 * @typedef {import('./interfaces.js').L10nAction} L10nAction
 * @typedef {import('./interfaces.js').Analyzer} Analyzer
 */
/**
 * Configuration for resource format handling.
 * Defines how resources are parsed and generated for a specific format.
 */
export class ResourceFormatConfig {
	static configMancerSample: {
		"@": string;
		id: string;
		defaultMessageFormat: string;
		resourceFilter: {
			"@": string;
		};
		$resourceGenerator: {
			"@": string;
		};
		segmentDecorators: FunctionConstructor[];
	};
	static configMancerFactory(obj: any): ResourceFormatConfig;
	/**
	 * Creates a new ResourceFormatConfig instance.
	 * @param {string} id - Unique identifier for this format.
	 */
	constructor(id: string);
	/** @returns {string} The format identifier. */
	get id(): string;
	/**
	 * Creates a FormatHandler from this configuration.
	 * @param {Record<string, FormatHandler>} formatHandlers - Map of format handlers by ID.
	 * @param {Record<string, Normalizer>} normalizers - Map of normalizers by ID.
	 * @returns {FormatHandler} The created format handler.
	 */
	createFormatHandler(formatHandlers: Record<string, FormatHandler>, normalizers: Record<string, Normalizer>): FormatHandler;
	/**
	 * Sets the resource filter for parsing raw content.
	 * @param {ResourceFilter} filter - The resource filter.
	 * @returns {ResourceFormatConfig} This instance for method chaining.
	 */
	resourceFilter(filter: ResourceFilter$3): ResourceFormatConfig;
	/**
	 * Sets the resource generator for producing translations.
	 * @param {ResourceGenerator} generator - The resource generator.
	 * @returns {ResourceFormatConfig} This instance for method chaining.
	 */
	resourceGenerator(generator: ResourceGenerator$2): ResourceFormatConfig;
	/**
	 * Sets the default message format for this resource format.
	 * @param {string} format - The message format identifier.
	 * @returns {ResourceFormatConfig} This instance for method chaining.
	 */
	defaultMessageFormat(format: string): ResourceFormatConfig;
	/**
	 * Sets the segment decorators for processing segments.
	 * @param {Function[]} decorators - Array of decorator functions.
	 * @returns {ResourceFormatConfig} This instance for method chaining.
	 */
	segmentDecorators(decorators: Function[]): ResourceFormatConfig;
	#private;
}
/**
 * Configuration for message format normalization.
 * Defines how strings are decoded, encoded, and normalized.
 */
export class MessageFormatConfig {
	static configMancerSample: {
		"@": string;
		id: string;
		decoders: FunctionConstructor[];
		textEncoders: FunctionConstructor[];
		codeEncoders: FunctionConstructor[];
		joiner: FunctionConstructor;
	};
	static configMancerFactory(obj: any): MessageFormatConfig;
	/**
	 * Creates a new MessageFormatConfig instance.
	 * @param {string} id - Unique identifier for this message format.
	 */
	constructor(id: string);
	/** @returns {string} The message format identifier. */
	get id(): string;
	/**
	 * Creates a Normalizer from this configuration.
	 * @returns {Normalizer} The created normalizer.
	 */
	createNormalizer(): Normalizer;
	/**
	 * Sets the decoder functions for parsing source strings.
	 * @param {Function[]} decoders - Array of decoder functions.
	 * @returns {MessageFormatConfig} This instance for method chaining.
	 */
	decoders(decoders: Function[]): MessageFormatConfig;
	/**
	 * Sets the text encoder functions for encoding output strings.
	 * @param {Function[]} encoders - Array of text encoder functions.
	 * @returns {MessageFormatConfig} This instance for method chaining.
	 */
	textEncoders(encoders: Function[]): MessageFormatConfig;
	/**
	 * Sets the code encoder functions for encoding placeholders.
	 * @param {Function[]} encoders - Array of code encoder functions.
	 * @returns {MessageFormatConfig} This instance for method chaining.
	 */
	codeEncoders(encoders: Function[]): MessageFormatConfig;
	/**
	 * Sets the joiner function for combining parts.
	 * @param {Function} joiner - The joiner function.
	 * @returns {MessageFormatConfig} This instance for method chaining.
	 */
	joiner(joiner: Function): MessageFormatConfig;
	#private;
}
/**
 * Configuration for a localization channel.
 * A channel defines the source/target adapters and format handlers for processing resources.
 */
export class ChannelConfig {
	static configMancerSample: {
		"@": string;
		id: string;
		defaultResourceFormat: string;
		source: {
			"@": string;
		};
		target: {
			"@": string;
		};
		translationPolicyPipeline: FunctionConstructor[];
		formatHandlers: {};
		channelOptions: {
			baseDir: string;
		};
	};
	static configMancerFactory(obj: any): ChannelConfig;
	/**
	 * Creates a new ChannelConfig instance.
	 * @param {string} id - Unique identifier for this channel.
	 * @param {string} [baseDir] - Optional base directory for relative paths.
	 */
	constructor(id: string, baseDir?: string);
	/** @returns {string} The channel identifier. */
	get id(): string;
	/**
	 * Creates a Channel instance from this configuration.
	 * @returns {Channel} The created channel.
	 */
	createChannel(): Channel$1;
	/**
	 * Sets the source adapter for this channel.
	 * @param {SourceAdapter} source - The source adapter.
	 * @returns {ChannelConfig} This instance for method chaining.
	 */
	source(source: SourceAdapter$4): ChannelConfig;
	/**
	 * Sets the target adapter for this channel.
	 * @param {TargetAdapter} target - The target adapter.
	 * @returns {ChannelConfig} This instance for method chaining.
	 */
	target(target: TargetAdapter$3): ChannelConfig;
	/**
	 * Adds a translation policy to the pipeline.
	 * @param {TranslationPolicy|TranslationPolicy[]} policy - The translation policy function(s).
	 * @returns {ChannelConfig} This instance for method chaining.
	 */
	policy(policy: TranslationPolicy$4 | TranslationPolicy$4[]): ChannelConfig;
	/**
	 * Adds a resource format configuration.
	 * @param {ResourceFormatConfig} resourceFormatConfig - The resource format configuration.
	 * @returns {ChannelConfig} This instance for method chaining.
	 */
	resourceFormat(resourceFormatConfig: ResourceFormatConfig): ChannelConfig;
	/**
	 * Sets the resource filter for the current resource format.
	 * @param {ResourceFilter} filter - The resource filter.
	 * @returns {ChannelConfig} This instance for method chaining.
	 */
	resourceFilter(filter: ResourceFilter$3): ChannelConfig;
	/**
	 * Sets the resource generator for the current resource format.
	 * @param {ResourceGenerator} generator - The resource generator.
	 * @returns {ChannelConfig} This instance for method chaining.
	 */
	resourceGenerator(generator: ResourceGenerator$2): ChannelConfig;
	/**
	 * Sets the default message format for the current resource format.
	 * @param {string} format - The message format identifier.
	 * @returns {ChannelConfig} This instance for method chaining.
	 */
	defaultMessageFormat(format: string): ChannelConfig;
	/**
	 * Sets the segment decorators for the current resource format.
	 * @param {Function[]} decorators - Array of decorator functions.
	 * @returns {ChannelConfig} This instance for method chaining.
	 */
	segmentDecorators(decorators: Function[]): ChannelConfig;
	/**
	 * Adds a message format configuration.
	 * @param {MessageFormatConfig} messageFormatConfig - The message format configuration.
	 * @returns {ChannelConfig} This instance for method chaining.
	 */
	messageFormat(messageFormatConfig: MessageFormatConfig): ChannelConfig;
	/**
	 * Sets the decoders for the current message format.
	 * @param {Function[]} decoders - Array of decoder functions.
	 * @returns {ChannelConfig} This instance for method chaining.
	 */
	decoders(decoders: Function[]): ChannelConfig;
	/**
	 * Sets the text encoders for the current message format.
	 * @param {Function[]} encoders - Array of text encoder functions.
	 * @returns {ChannelConfig} This instance for method chaining.
	 */
	textEncoders(encoders: Function[]): ChannelConfig;
	/**
	 * Sets the code encoders for the current message format.
	 * @param {Function[]} encoders - Array of code encoder functions.
	 * @returns {ChannelConfig} This instance for method chaining.
	 */
	codeEncoders(encoders: Function[]): ChannelConfig;
	/**
	 * Sets the joiner function for the current message format.
	 * @param {Function} joiner - The joiner function.
	 * @returns {ChannelConfig} This instance for method chaining.
	 */
	joiner(joiner: Function): ChannelConfig;
	#private;
}
/**
 * Main configuration class for L10n Monster.
 * This class is used to initialize MonsterManager and run all localization processes.
 */
declare class L10nMonsterConfig$1 {
	static configMancerSample: {
		"@": string;
		baseDir: string;
		$channels: {};
		$providers: any[];
		$autoSnap: boolean;
		$saveFailedJobs: boolean;
		$tmStores: {};
		$opsStore: {
			"@": string;
		};
		$actions: FunctionConstructor[];
		$analyzers: FunctionConstructor[];
		$currencyFormatter: {
			"@": string;
		};
		$sourceDB: string;
		$tmDB: string;
	};
	static configMancerFactory(obj: any): L10nMonsterConfig$1;
	/**
	 * Initializes the L10nMonsterConfig with a base directory.
	 * @param {string} baseDir - The base directory for relative paths.
	 * @throws {string} Throws an error if the base directory is not provided.
	 */
	constructor(baseDir: string);
	/** @type {Record<string, ChannelConfig>} Configuration for different channels. */
	channels: Record<string, ChannelConfig>;
	/** @type {Record<string, ResourceFormatConfig>} Configuration for different formats. */
	formats: Record<string, ResourceFormatConfig>;
	/** @type {TranslationProvider[]} Providers for the localization process. */
	providers: TranslationProvider$4[];
	/** @type {boolean} Whether to automatically create snapshots at each run. */
	autoSnap: boolean;
	/** @type {boolean} Whether to save failed jobs as pending. */
	saveFailedJobs: boolean;
	/** @type {Record<string, TMStore>|undefined} Configuration for the TM stores. */
	tmStores: Record<string, TMStore$3> | undefined;
	/** @type {Record<string, SnapStore>|undefined} Configuration for the snap stores. */
	snapStores: Record<string, SnapStore$2> | undefined;
	/** @type {OpsStoreInterface | undefined} Operation logs store. */
	opsStore: OpsStoreInterface$4 | undefined;
	/** @type {L10nAction[]} List of actions available for the localization process. */
	actions: L10nAction$2[];
	/** @type {Analyzer[]|undefined} Analyzer functions for content analysis. */
	analyzers: Analyzer$8[] | undefined;
	/** @type {Intl.NumberFormat|undefined} Currency formatter for cost estimates. */
	currencyFormatter: Intl.NumberFormat | undefined;
	/** @type {string|boolean|undefined} Source database filename or false to disable. */
	sourceDB: string | boolean | undefined;
	/** @type {string|boolean|undefined} TM database filename or false to disable. */
	tmDB: string | boolean | undefined;
	/**
	 * Configures a channel.
	 * @param {ChannelConfig | Array<ChannelConfig>} config - The configuration object for the channel.
	 * @returns {L10nMonsterConfig} Returns the instance for method chaining.
	 */
	channel(config: ChannelConfig | Array<ChannelConfig>): L10nMonsterConfig$1;
	/**
	 * Adds a translation provider.
	 * @param {TranslationProvider|TranslationProvider[]} provider - The translation provider(s).
	 * @returns {L10nMonsterConfig} Returns the instance for method chaining.
	 * @throws {Error} Throws if provider with same id already exists or if provider is invalid.
	 */
	provider(provider: TranslationProvider$4 | TranslationProvider$4[]): L10nMonsterConfig$1;
	/**
	 * Configures operations for the localization process.
	 * @param {Object} config - The operations configuration object.
	 * @param {boolean} [config.autoSnap] - Configuration for the snapshot store.
	 * @param {boolean} [config.saveFailedJobs] - Whether to save failed jobs as pending.
	 * @param {Analyzer[]} [config.analyzers] - Configuration for analyzers.
	 * @param {OpsStoreInterface} [config.opsStore] - Operations store for persistence.
	 * @param {Intl.NumberFormat} [config.currencyFormatter] - A currency formatter for estimated costs.
	 * @param {string|boolean} [config.sourceDB] - Source database filename or false to disable writing DB files.
	 * @param {string|boolean} [config.tmDB] - TM database filename or false to disable writing DB files.
	 * @returns {L10nMonsterConfig} Returns the instance for method chaining.
	 */
	operations({ autoSnap, saveFailedJobs, analyzers, opsStore, currencyFormatter, sourceDB, tmDB, }: {
		autoSnap?: boolean;
		saveFailedJobs?: boolean;
		analyzers?: Analyzer$8[];
		opsStore?: OpsStoreInterface$4;
		currencyFormatter?: Intl.NumberFormat;
		sourceDB?: string | boolean;
		tmDB?: string | boolean;
	}): L10nMonsterConfig$1;
	/**
	 * Adds a TM store to the set of available TM Stores.
	 * @param {import('../index.js').TMStore | Array<import('../index.js').TMStore>} storeInstance - The TM Store instance or array of instances.
	 * @returns {L10nMonsterConfig} Returns the config for method chaining.
	 */
	tmStore(storeInstance: TMStore$4 | Array<TMStore$4>): L10nMonsterConfig$1;
	/**
	 * Adds a Snap Store to the set of available Snap Stores.
	 * @param {import('../index.js').SnapStore | Array<import('../index.js').SnapStore>} storeInstance - The Snap Store instance or array of instances.
	 * @returns {L10nMonsterConfig} Returns the config for method chaining.
	 */
	snapStore(storeInstance: SnapStore$3 | Array<SnapStore$3>): L10nMonsterConfig$1;
	/**
	 * Adds an action to the list of available actions for the localization process.
	 * @param {L10nAction} actionDefinition - The action definition object.
	 * @returns {L10nMonsterConfig} Returns the instance for method chaining.
	 */
	action(actionDefinition: L10nAction$2): L10nMonsterConfig$1;
	/**
	 * Sets the verbosity level for logging.
	 * @param {number} level - The verbosity level to set.
	 * @returns {L10nMonsterConfig} Returns the instance for method chaining.
	 */
	verbose(level: number): L10nMonsterConfig$1;
	/**
	 * Sets the regression mode for testing.
	 * @param {boolean} mode - The regression mode to set.
	 * @returns {L10nMonsterConfig} Returns the instance for method chaining.
	 */
	regression(mode: boolean): L10nMonsterConfig$1;
	/**
	 * An optional initialization callback to finish initilizing async children before use.
	 * @param {MonsterManager} [mm] - The initialized instance of Monster Manager
	 * @return {Promise<void>}
	 */
	init(mm?: MonsterManager$1): Promise<void>;
	/**
	 * Runs the localization process with the given global options and callback.
	 * @param {Function} cb - The callback function to execute after initialization.
	 * @returns {Promise} Returns a promise that resolves with the response from the callback.
	 * @throws {string} Throws an error if the localization process fails.
	 */
	run(cb: Function): Promise<any>;
}
/**
 * Factory functions for creating configuration objects.
 * @type {{
 *   l10nMonster: (baseDir: string) => L10nMonsterConfig,
 *   channel: (id: string, baseDir?: string) => ChannelConfig,
 *   resourceFormat: (id: string) => ResourceFormatConfig,
 *   messageFormat: (id: string) => MessageFormatConfig
 * }}
 */
export const config: {
	l10nMonster: (baseDir: string) => L10nMonsterConfig$1;
	channel: (id: string, baseDir?: string) => ChannelConfig;
	resourceFormat: (id: string) => ResourceFormatConfig;
	messageFormat: (id: string) => MessageFormatConfig;
};
type ResourceFilter$3 = ResourceFilter;
type ResourceGenerator$2 = ResourceGenerator;
type SourceAdapter$4 = SourceAdapter;
type TargetAdapter$3 = TargetAdapter;
type TMStore$3 = TMStore;
type SnapStore$2 = SnapStore;
type TranslationProvider$4 = TranslationProvider;
type TranslationPolicy$4 = TranslationPolicy;
type OpsStoreInterface$4 = OpsStoreInterface;
type L10nAction$2 = L10nAction;
type Analyzer$8 = Analyzer;
/**
 * Get the required plural forms for a source language.
 * @param {string} [lang] - Source language code (e.g., 'en', 'ar').
 *   If undefined, returns default plural forms ['one', 'other'].
 *   If language is not in CLDR, returns default plural forms.
 * @returns {string[]} Array of required plural forms for the source language.
 */
export function requiredSourcePluralForms(lang?: string): string[];
/**
 * Get the superset of required plural forms for target languages.
 * @param {string[]} [langs] - Array of target language codes (e.g., ['ar', 'ru']).
 *   If empty or undefined, returns all 6 plural forms (to be safe for any target).
 *   If a language is not in CLDR, its forms default to ['one', 'other'].
 * @returns {string[]} Array of required plural forms in CLDR canonical order.
 */
export function requiredTargetPluralForms(langs?: string[]): string[];
export const l10nMonsterPackage: "@l10nmonster/core";
export const l10nMonsterVersion: "3.1.1";
export const l10nMonsterDescription: "L10n Monster Core Module";
type Segment$2 = Segment;
type Part$6 = Part;
type PlaceholderPart$5 = PlaceholderPart;
type NormalizedString$7 = NormalizedString$1;
type StructuredNotes$3 = StructuredNotes$1;
type ResourceHeader$2 = ResourceHeader;
type ChannelOptions$2 = ChannelOptions;
type SourceAdapter$5 = SourceAdapter;
type TargetAdapter$4 = TargetAdapter;
type TMStore$4 = TMStore;
type TMStoreTOC$3 = TMStoreTOC;
type TMStoreBlock$1 = TMStoreBlock;
type JobPropsTusPair$5 = JobPropsTusPair;
type SnapStore$3 = SnapStore;
type JobProps$3 = JobProps$1;
type Job$6 = Job;
type TranslationPolicy$5 = TranslationPolicy;
type ResourceFilter$4 = ResourceFilter;
type ResourceGenerator$3 = ResourceGenerator;
type GenerateResourceParams$2 = GenerateResourceParams;
type Subresource$2 = Subresource;
type EncodeFlags$4 = EncodeFlags;
type DecoderFunction$4 = DecoderFunction;
type TextEncoderFunction$3 = TextEncoderFunction;
type CodeEncoderFunction$2 = CodeEncoderFunction;
type PartTransformer$1 = PartTransformer;
type TranslationProvider$5 = TranslationProvider;
type StatusProperty$1 = StatusProperty;
type StatusProperties$2 = StatusProperties;
type XmlTu$2 = XmlTu;
type TranslateChunkArgs$2 = TranslateChunkArgs;
type ProviderTranslateChunkArgs$3 = ProviderTranslateChunkArgs;
type ProviderResponseChunk$3 = ProviderResponseChunk;
type TranslatedChunk$3 = TranslatedChunk;
type ChunkTuMeta$1 = ChunkTuMeta;
type TranslateChunkOpResult$2 = TranslateChunkOpResult;
type ActionHelp$1 = ActionHelp;
type L10nAction$3 = L10nAction;
type L10nActionClass$1 = L10nActionClass;
type AnalysisResult$1 = AnalysisResult;
type Analyzer$9 = Analyzer;
type AnalyzerTU$5 = AnalyzerTU;
type OpsStoreInterface$5 = OpsStoreInterface;
type SegmentDecorator$3 = SegmentDecorator;
type SegmentDecoratorFactory$2 = SegmentDecoratorFactory;
type NormalizedSegment$5 = NormalizedSegment;
type FileStoreDelegate$2 = FileStoreDelegate;
type DALManager$4 = DALManager;
type TranslationPlan$3 = TranslationPlan;
type PolicyContext$2 = PolicyContext;
type Channel$3 = Channel$1;
type FormatHandler$2 = FormatHandler;
type Normalizer$1 = Normalizer;
type ResourceHandle$4 = ResourceHandle$2;

declare namespace xml {
	export { CDataDecoder, entityDecoder, entityEncoder, tagDecoder };
}
declare namespace actions {
	export { analyze, monster, ops, source, tm, translate };
}
declare namespace opsManager {
	export { OpsStoreInterface$2 as OpsStoreInterface, SerializedOp$2 as SerializedOp, createOp, createTask, deserializeTask, hydrateTaskFromStore, registerOp, setOpsStore };
}
declare namespace adapters {
	export { FsSource, FsTarget, HttpSource };
}
declare namespace analyzers {
	export { Analyzer$7 as Analyzer, AnalyzerTU$4 as AnalyzerTU, DuplicateSource, ExportTranslationGrid, FindByExpansion, FindInTarget, MismatchedTags, NormalizedString$4 as NormalizedString, SmellySource, TextExpansionSummary };
}
declare namespace decorators {
	export { SequenceGenerator };
}
declare namespace filters {
	export { MNFv1Filter };
}
declare namespace normalizers {
	export { DecoderFunction$2 as DecoderFunction, EncodeFlags$2 as EncodeFlags, Part$3 as Part, bracePHDecoder, defaultCodeEncoder, defaultTextEncoder, doublePercentDecoder, doublePercentEncoder, gatedEncoder, keywordTranslatorMaker, namedDecoder };
}
declare namespace policies {
	export { PolicyContext$1 as PolicyContext, TranslationPlan$2 as TranslationPlan, TranslationPolicy$3 as TranslationPolicy, byProject, fixedTargets, minimizePluralForms };
}
declare namespace providers {
	export { BaseTranslationProvider, ChunkedRemoteTranslationProvider, Grandfather, InternalLeverageHoldout, InvisicodeProvider, LLMTranslationProvider, LanguageVariantProvider, Repetition, Visicode };
}
declare namespace regex {
	export { DecoderFunction$3 as DecoderFunction, EncodeFlags$3 as EncodeFlags, Part$4 as Part, PlaceholderPart$3 as PlaceholderPart, TextEncoderFunction$2 as TextEncoderFunction, decoderMaker, encoderMaker };
}
declare namespace stores {
	export { BaseFileBasedSnapStore, BaseJsonlTmStore, FsJsonlTmStore, FsLegacyJsonTmStore, FsOpsStore, FsStoreDelegate, LegacyFileBasedTmStore, OpsStore };
}
declare namespace utils {
	export { Job$5 as Job, JobProps$2 as JobProps, NormalizedString$6 as NormalizedString, Part$5 as Part, PlaceholderMap, PlaceholderPart$4 as PlaceholderPart, StructuredNotes$2 as StructuredNotes, TUMaps, balancedSplitWithObjects, consolidateDecodedParts, decodeNormalizedString, extractNormalizedPartsFromXmlV1, extractNormalizedPartsV1, extractStructuredNotes, fixCaseInsensitiveKey, flattenNormalizedSourceToOrdinal, flattenNormalizedSourceToXmlV1, flattenNormalizedSourceV1, generateGuid, getIteratorFromJobPair, getNormalizedString, getTUMaps, integerToLabel, normalizedStringsAreEqual, phMatcherMaker, sourceAndTargetAreCompatible, validate };
}

export {
	ActionHelp$1 as ActionHelp,
	AnalysisResult$1 as AnalysisResult,
	Analyzer$9 as Analyzer,
	AnalyzerTU$5 as AnalyzerTU,
	Channel$3 as Channel,
	ChannelOptions$2 as ChannelOptions,
	ChunkTuMeta$1 as ChunkTuMeta,
	CodeEncoderFunction$2 as CodeEncoderFunction,
	DALManager$4 as DALManager,
	DecoderFunction$4 as DecoderFunction,
	EncodeFlags$4 as EncodeFlags,
	FileStoreDelegate$2 as FileStoreDelegate,
	FormatHandler$2 as FormatHandler,
	GenerateResourceParams$2 as GenerateResourceParams,
	Job$6 as Job,
	JobProps$3 as JobProps,
	JobPropsTusPair$5 as JobPropsTusPair,
	L10nAction$3 as L10nAction,
	L10nActionClass$1 as L10nActionClass,
	L10nMonsterConfig$1 as L10nMonsterConfig,
	MonsterManager$1 as MonsterManager,
	NormalizedSegment$5 as NormalizedSegment,
	NormalizedString$7 as NormalizedString,
	Normalizer$1 as Normalizer,
	OpsStoreInterface$5 as OpsStoreInterface,
	Part$6 as Part,
	PartTransformer$1 as PartTransformer,
	PlaceholderPart$5 as PlaceholderPart,
	PolicyContext$2 as PolicyContext,
	ProviderResponseChunk$3 as ProviderResponseChunk,
	ProviderTranslateChunkArgs$3 as ProviderTranslateChunkArgs,
	ResourceFilter$4 as ResourceFilter,
	ResourceGenerator$3 as ResourceGenerator,
	ResourceHandle$4 as ResourceHandle,
	ResourceHeader$2 as ResourceHeader,
	Segment$2 as Segment,
	SegmentDecorator$3 as SegmentDecorator,
	SegmentDecoratorFactory$2 as SegmentDecoratorFactory,
	SnapStore$3 as SnapStore,
	SourceAdapter$5 as SourceAdapter,
	StatusProperties$2 as StatusProperties,
	StatusProperty$1 as StatusProperty,
	StructuredNotes$3 as StructuredNotes,
	Subresource$2 as Subresource,
	TMStore$4 as TMStore,
	TMStoreBlock$1 as TMStoreBlock,
	TMStoreTOC$3 as TMStoreTOC,
	TargetAdapter$4 as TargetAdapter,
	TextEncoderFunction$3 as TextEncoderFunction,
	TranslateChunkArgs$2 as TranslateChunkArgs,
	TranslateChunkOpResult$2 as TranslateChunkOpResult,
	TranslatedChunk$3 as TranslatedChunk,
	TranslationPlan$3 as TranslationPlan,
	TranslationPolicy$5 as TranslationPolicy,
	TranslationProvider$5 as TranslationProvider,
	XmlTu$2 as XmlTu,
	actions,
	adapters,
	analyzers,
	decorators,
	filters,
	l10nMonsterVersion as coreVersion,
	normalizers,
	opsManager,
	policies,
	providers,
	regex,
	stores,
	utils,
	xml,
};

export {};
