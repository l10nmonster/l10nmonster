import { ResourceHandle } from './resourceHandle.js';

/**
 * @class Channel
 * @classdesc Represents a channel for managing localization resources,
 * including fetching source content, applying translation policies,
 * and committing translated resources.
 */
export class Channel {
    #id;
    #source;
    #formatHandlers;
    #defaultResourceFormat;
    #target;
    #translationPolicyPipeline;

    constructor({ id, source, formatHandlers, defaultResourceFormat, target, translationPolicyPipeline }) {
        this.#id = id;
        this.#source = source;
        this.#formatHandlers = formatHandlers;
        this.#defaultResourceFormat = defaultResourceFormat;
        this.#target = target;
        this.#translationPolicyPipeline = translationPolicyPipeline;
    }

    makeResourceHandleFromHeader(resourceHeader) {
         // sources can provide resources of different formats but we have a default
        const resourceFormat = resourceHeader.resourceFormat ?? this.#defaultResourceFormat;
        if (!resourceHeader.sourceLang) {
            throw new Error(`Missing sourceLang in resource handle: ${JSON.stringify(resourceHeader)}`);
        }
        const formatHandler = this.#formatHandlers[resourceFormat];
        if (!formatHandler) {
            throw new Error(`No format handler found for resource format: ${resourceFormat}`);
        }
        return new ResourceHandle({
            channel: this.#id,
            resourceFormat: this.#defaultResourceFormat,
            formatHandler,
            ...resourceHeader,
        });
    }

    async #makeFullResourceWithPolicyApplied(resourceHeader, rawResource) {
        const handle = this.makeResourceHandleFromHeader(resourceHeader);
        await handle.loadResourceFromRaw(rawResource, { isSource: true });
        const targetLangs = new Set();
        const stats = {};
        const getStatsKey = translationPlan => Object.entries(translationPlan).map(([targetLang, q]) => `${targetLang}:${q}`).sort().join(',');
        for (const segment of handle.segments) {
            const policyContext = { plan: {}, seg: segment, res: handle };
            this.#translationPolicyPipeline.forEach((policy, index) => {
                const returnedContext = policy(policyContext);
                if (returnedContext) {
                    const { res, seg, ...segmentProps } = returnedContext; // preserve res and seg in policyContext
                    Object.assign(policyContext, segmentProps);
                } else {
                    const policyName = policy.name || `policy[${index}]`;
                    throw new Error(`Policy ${policyName} returned nothing for resource ${segment.rid} segment ${segment.sid}`);
                }
            });
            const { res, seg, ...segmentProps } = policyContext; // extract segment properties generated by plan
            Object.assign(segment, segmentProps);
            Object.keys(segment.plan).forEach(targetLang => targetLangs.add(targetLang));
            const statsKey = getStatsKey(segment.plan);
            stats[statsKey] ??= 0;
            stats[statsKey]++;
        }
        const defaultPlanKey = Object.entries(stats).sort((a, b) => b[1] - a[1])[0][0];
        let plan = {};
        for (const segment of handle.segments) {
            const statsKey = getStatsKey(segment.plan);
            if (statsKey === defaultPlanKey) {
                plan = segment.plan;
                delete segment.plan;
            }
        }
        handle.plan = plan;
        handle.targetLangs = Array.from(targetLangs).sort();
        return handle;
    }

    async *getAllNormalizedResources(options) {
        for await (const [resourceHeader, rawResource] of this.#source.fetchAllResources(options)) {
            yield this.#makeFullResourceWithPolicyApplied(resourceHeader, rawResource);
        }
    }

    async getExistingTranslatedResource(resourceHandle, targetLang) {
        const rawResource = await this.#target.fetchTranslatedResource(targetLang, resourceHandle.id);
        const translatedResource = this.makeResourceHandleFromHeader(resourceHandle);
        return translatedResource.loadResourceFromRaw(rawResource, { isSource: false });
    }

    async commitTranslatedResource(targetLang, resourceId, rawResource) {
        const translatedResourceId = this.#target.translatedResourceId(targetLang, resourceId);
        await this.#target.commitTranslatedResource(targetLang, resourceId, rawResource);
        return translatedResourceId;
    }

}
