import { logVerbose } from '../l10nContext.js';

/**
 * @class ResourceHandle
 * @classdesc Represents a handle to a localization resource.
 * It contains metadata about the resource, such as its ID, channel, format,
 * source and target languages, and the raw content or parsed segments.
 * It uses a format handler to load and normalize raw resource content and
 * to generate translated raw resources.
 */
export class ResourceHandle {
    #formatHandler;

    constructor({ id, channel, modified, resourceFormat, formatHandler, sourceLang, targetLangs, plan, prj, raw, segments, subresources, ...other }) {
        this.id = id;
        this.channel = channel;
        this.modified = modified;
        this.resourceFormat = resourceFormat;
        this.#formatHandler = formatHandler;
        this.sourceLang = sourceLang;
        this.targetLangs = targetLangs;
        this.plan = plan;
        this.prj = prj;
        this.raw = raw;
        this.segments = segments;
        this.subresources = subresources;
        if (Object.keys(other).length > 1) {
            logVerbose`Unknown properties in resource handle: ${Object.keys(other).join(', ')}`;
        }
    }

    loadFromNormalizedResource(normalizedResource) {
        const { segments, subresources } = normalizedResource;
        this.segments = segments;
        this.subresources = subresources;
        return this;
    }

    async loadResourceFromRaw(rawResource, options) {
        const normalizedResource = await this.#formatHandler.getNormalizedResource(this.id, rawResource, {
            isSource: options.isSource,
            sourceLang: this.sourceLang,
            targetLangs: this.targetLangs,
        });
        this.raw = rawResource;
        return this.loadFromNormalizedResource(normalizedResource);
    }

    async generateTranslatedRawResource(tm) {
        return this.#formatHandler.generateTranslatedResource(this, tm);
    }

    async applyPolicies(translationPolicyPipeline) {
        const targetLangs = new Set();
        for (const segment of this.segments) {
            const policyContext = { plan: {}, seg: segment, res: this };
            translationPolicyPipeline.forEach((policy, index) => {
                const returnedContext = policy(policyContext);
                if (returnedContext) {
                    // eslint-disable-next-line no-unused-vars
                    const { res, seg, ...segmentProps } = returnedContext; // preserve res and seg in policyContext
                    Object.assign(policyContext, segmentProps);
                } else {
                    const policyName = policy.name || `policy[${index}]`;
                    throw new Error(`Policy ${policyName} returned nothing for resource ${segment.rid} segment ${segment.sid}`);
                }
            });
            // eslint-disable-next-line no-unused-vars
            const { res, seg, ...segmentProps } = policyContext; // extract segment properties generated by plan
            Object.assign(segment, segmentProps);
            Object.keys(segment.plan).forEach(targetLang => targetLangs.add(targetLang));
        }
        this.targetLangs = Array.from(targetLangs).sort();
    }
}
