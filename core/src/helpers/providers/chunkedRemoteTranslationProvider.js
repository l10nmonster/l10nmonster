import { L10nContext, providers, logVerbose, logInfo, styleString, utils, opsManager } from '@l10nmonster/core';

const MAX_CHAR_LENGTH = 9900;
const MAX_CHUNK_SIZE = 125;

/**
 * @typedef {object} ChunkedRemoteTranslationProviderOptions
 * @property {string} [id] - Global identifier for the provider.
 * @property {Record<string, string[]>} [supportedPairs] - Supported language pairs for the provider.
 * @property {number} [costPerWord] - The estimated cost per word for the provider.
 * @property {number} [costPerMChar] - The estimated cost per million characters for the provider.
 * @property {number} quality - The quality score (e.g., 0-100) to assign to translations generated by this provider. This is required.
 * @property {number} [maxCharLength=9900] - Maximum total characters allowed in a single API request chunk. Defaults to 9900 if not provided.
 * @property {number} [maxChunkSize=125] - Maximum number of text segments (strings) allowed in a single API request chunk. Defaults to 125 if not provided.
 * @property {(languageCode: string) => string} [languageMapper] - An optional function to map standard language codes
 *   (e.g., 'en-US') to provider-specific codes if needed. Receives a standard language code and should return the
 *   provider-specific code. If omitted, language codes are used as-is.
 */

/**
 * Base class for providers that need to enforce chunking of input strings and asynchronous translation.
 * @class ChunkedRemoteTranslationProvider
 * @extends providers.BaseTranslationProvider
 * @property {Boolean} synchProvider - Whether the provider is synchronous (i.e. completes after start() is called) or asynchronous.
 */
export class ChunkedRemoteTranslationProvider extends providers.BaseTranslationProvider {
    synchProvider = true;

    #languageMapper;
    #opNames = {};

    /**
     * Initializes a new instance of the ChunkedRemoteTranslationProvider class.
     * @param {ChunkedRemoteTranslationProviderOptions} options - Configuration options for the provider.
     */
    constructor({ maxCharLength, maxChunkSize, languageMapper, ...options }) {
        if (options.quality === undefined) {
            throw new Error('You must specify quality for ChunkedRemoteTranslationProvider');
        }
        super(options);
        this.maxCharLength = maxCharLength ?? MAX_CHAR_LENGTH;
        this.maxChunkSize = maxChunkSize ?? MAX_CHUNK_SIZE;
        this.#languageMapper = languageMapper;
        this.#opNames.synchTranslateChunk = `${this.id}.synchTranslateChunk`;
        this.#opNames.mergeTranslatedChunks = `${this.id}.mergeTranslatedChunks`;
        this.#opNames.asynchTranslateChunk = `${this.id}.asynchTranslateChunk`;
        this.#opNames.asynchWaitSubmissions = `${this.id}.asynchWaitSubmissions`;
        this.#opNames.asynchFetchChunk = `${this.id}.asynchFetchChunk`;
        opsManager.registerOp(this.synchTranslateChunk.bind(this), { opName: this.#opNames.synchTranslateChunk, idempotent: false });
        opsManager.registerOp(this.mergeTranslatedChunks.bind(this), { opName: this.#opNames.mergeTranslatedChunks, idempotent: true });
        opsManager.registerOp(this.asynchTranslateChunk.bind(this), { opName: this.#opNames.asynchTranslateChunk, idempotent: false });
        opsManager.registerOp(this.asynchWaitSubmissions.bind(this), { opName: this.#opNames.asynchWaitSubmissions, idempotent: true });
        opsManager.registerOp(this.asynchFetchChunk.bind(this), { opName: this.#opNames.asynchFetchChunk, idempotent: true });
    }

    createTask(job) {
        logVerbose`ChunkedRemoteTranslationProvider creating task for job ${job.jobGuid}`;
        const { tus, ...jobResponse } = job;
        const sourceLang = this.#languageMapper ? this.#languageMapper(job.sourceLang) : job.sourceLang;
        const targetLang = this.#languageMapper ? this.#languageMapper(job.targetLang) : job.targetLang;
        const tuMeta = {};
        const payload = tus.map((tu, idx) => {
            const [source, phMap ] = utils.flattenNormalizedSourceToXmlV1(tu.nsrc);
            if (Object.keys(phMap).length > 0) {
                tuMeta[idx] = phMap;
            }
            const xmlTu = { bundle: tu.rid, key: tu.sid };
            tu.notes?.desc && (xmlTu.notes = tu.notes.desc);
            xmlTu.source = source; // adding source second so that LLMs see notes first
            return xmlTu;
        });
        const requestTranslationsTask = opsManager.createTask(this.id, this.synchProvider ? this.#opNames.mergeTranslatedChunks : this.#opNames.asynchWaitSubmissions);
        jobResponse.taskName = L10nContext.regression ? 'x' : requestTranslationsTask.taskName;
        const chunkSizes = [];
        for (let currentIdx = 0; currentIdx < payload.length;) {
            const xmlTus = [];
            let currentTotalLength = 0;
            while (currentIdx < payload.length && xmlTus.length < this.maxChunkSize && payload[currentIdx].source.length + currentTotalLength < this.maxCharLength) {
                currentTotalLength += payload[currentIdx].source.length;
                xmlTus.push(payload[currentIdx]);
                currentIdx++;
            }
            if (xmlTus.length === 0) {
                throw new Error(`String at index ${currentIdx} exceeds ${this.maxCharLength} max char length`);
            }
            logInfo`Preparing chunked translation with ${xmlTus.length} ${[xmlTus.length, 'string', 'strings']}, total char length: ${currentTotalLength}`;
            const args = this.prepareTranslateChunkArgs({ sourceLang, targetLang, xmlTus, jobGuid: job.jobGuid, instructions: job.instructions, chunk: chunkSizes.length });
            requestTranslationsTask.rootOp.enqueue(this.synchProvider ? this.#opNames.synchTranslateChunk : this.#opNames.asynchTranslateChunk, args);
            chunkSizes.push(xmlTus.length);
        }
        requestTranslationsTask.rootOp.args = {
            guids: tus.map(tu => tu.guid),
            tuMeta,
            quality: this.quality,
            ts: L10nContext.regression ? 1 : new Date().getTime(),
            chunkSizes,
            jobResponse,
        };
        return requestTranslationsTask;
    }

    prepareTranslateChunkArgs(chunk) {
        return chunk;
    }

    synchTranslateChunk(op) {
        throw new Error(`synchTranslateChunk not implemented in ${this.constructor.name}`);
    }

    async mergeTranslatedChunks(op) {
        const { guids, tuMeta, quality, ts, chunkSizes, jobResponse } = op.args;
        const convertedChuncks = op.inputs.map(input => this.convertTranslationResponse(input));
        convertedChuncks.forEach((convertedChunk, idx) => {
            if (convertedChunk.length !== chunkSizes[idx]) {
                throw new Error(`Expected chunk ${idx} to have ${chunkSizes[idx]} translations but got ${convertedChunk.length}`);
            }
        });
        const translations = convertedChuncks.flat(1);
        jobResponse.tus = guids.map((guid, idx) => {
            const { tgt, ...tu } = translations[idx] || {};
            tu.guid = guid
            tu.ts = ts;
            tu.q = quality;
            tu.ntgt = utils.extractNormalizedPartsFromXmlV1(tgt, tuMeta[idx] || {});
            return tu;
        });
        return jobResponse;
    }

    convertTranslationResponse(chunk) {
        throw new Error(`convertTranslationResponse not implemented in ${this.constructor.name}`);
    }

    async continue(job) {
        logVerbose`ChunkedRemoteTranslationProvider provider updating job ${job.jobGuid}`;
        const { inflight, ...jobResponse } = await super.continue(job);
        try {
            const requestTranslationsTask = opsManager.createTask(this.id, this.#opNames.mergeTranslatedChunks);
            job.envelope.chunkSizes.forEach(async (chunkSize, chunk) => {
                L10nContext.logger.info(`Enqueue chunk fetcher for job: ${job.jobGuid} chunk:${chunk} chunkSize:${chunkSize}`);
                requestTranslationsTask.rootOp.enqueue(this.#opNames.asynchFetchChunk, {
                    jobGuid: job.jobGuid,
                    chunk,
                    chunkSize,
                });
            });
            requestTranslationsTask.rootOp.args = {
                guids: inflight,
                tuMeta: job.envelope.tuMeta,
                quality: this.quality,
                ts: L10nContext.regression ? 1 : new Date().getTime(),
                chunkSizes: job.envelope.chunkSizes,
            };
            const receivedTus = await requestTranslationsTask.execute();
            jobResponse.tus = receivedTus;
            jobResponse.taskName = L10nContext.regression ? 'x' : requestTranslationsTask.taskName;
            return jobResponse;
        // eslint-disable-next-line no-unused-vars
        } catch (error) {
            return job; // getting errors is expected, just leave the job pending
        }
    }

    asynchTranslateChunk(op) {
        throw new Error(`asynchTranslateChunk not implemented in ${this.constructor.name}`);
    }

    async asynchWaitSubmissions(op) {
        const { guids, tuMeta, chunkSizes, jobResponse } = op.args;
        logVerbose`ChunkedRemoteTranslationProvider submitted ${op.inputs.length} chunks with ${guids.length} guids`;
        jobResponse.inflight = guids;
        jobResponse.envelope = { chunkSizes, tuMeta };
        jobResponse.status = 'pending';
        return jobResponse;
    }

    asynchFetchChunk(op) {
        throw new Error(`asynchFetchChunk not implemented in ${this.constructor.name}`);
    }

    async info() {
        const info = await super.info();
        info.description.push(styleString`Max chunk size: ${this.maxChunkSize.toLocaleString()}, max char length: ${this.maxCharLength.toLocaleString()}`);
        return info;
    }
}
