import { L10nContext, providers, logVerbose, logInfo, styleString, utils, opsManager, logError, logWarn } from '@l10nmonster/core';

const MAX_CHAR_LENGTH = 9900;
const MAX_CHUNK_SIZE = 125;

/**
 * @typedef {object} ChunkedRemoteTranslationProviderOptions
 * @property {string} [id] - Global identifier for the provider.
 * @property {Record<string, string[]>} [supportedPairs] - Supported language pairs for the provider.
 * @property {number} [costPerWord] - The estimated cost per word for the provider.
 * @property {number} [costPerMChar] - The estimated cost per million characters for the provider.
 * @property {number} quality - The quality score (e.g., 0-100) to assign to translations generated by this provider. This is required.
 * @property {number} [maxCharLength=9900] - Maximum total characters allowed in a single API request chunk. Defaults to 9900 if not provided.
 * @property {number} [maxChunkSize=125] - Maximum number of text segments (strings) allowed in a single API request chunk. Defaults to 125 if not provided.
 * @property {(languageCode: string) => string} [languageMapper] - An optional function to map standard language codes
 *   (e.g., 'en-US') to provider-specific codes if needed. Receives a standard language code and should return the
 *   provider-specific code. If omitted, language codes are used as-is.
 */

/**
 * Base class for providers that need to enforce chunking of input strings and asynchronous translation.
 * @class ChunkedRemoteTranslationProvider
 * @extends providers.BaseTranslationProvider
 */
export class ChunkedRemoteTranslationProvider extends providers.BaseTranslationProvider {

    #languageMapper;
    #opNames = {};

    /**
     * Initializes a new instance of the ChunkedRemoteTranslationProvider class.
     * @param {ChunkedRemoteTranslationProviderOptions} options - Configuration options for the provider.
     */
    constructor({ maxCharLength, maxChunkSize, languageMapper, ...options }) {
        if (options.quality === undefined) {
            throw new Error('You must specify quality for ChunkedRemoteTranslationProvider');
        }
        super(options);
        this.maxCharLength = maxCharLength ?? MAX_CHAR_LENGTH;
        this.maxChunkSize = maxChunkSize ?? MAX_CHUNK_SIZE;
        this.#languageMapper = languageMapper;
        this.#opNames.startTranslateChunkOp = `${this.id}.startTranslateChunkOp`;
        this.#opNames.mergeTranslatedChunksOp = `${this.id}.mergeTranslatedChunksOp`;
        this.#opNames.continueTranslateChunkOp = `${this.id}.continueTranslateChunkOp`;
        opsManager.registerOp(this.startTranslateChunkOp.bind(this), { opName: this.#opNames.startTranslateChunkOp, idempotent: false });
        opsManager.registerOp(this.mergeTranslatedChunksOp.bind(this), { opName: this.#opNames.mergeTranslatedChunksOp, idempotent: true });
        opsManager.registerOp(this.continueTranslateChunkOp.bind(this), { opName: this.#opNames.continueTranslateChunkOp, idempotent: true });
    }

    createTask(job) {
        logVerbose`ChunkedRemoteTranslationProvider creating task for job ${job.jobGuid}`;
        const { tus, ...jobResponse } = job;
        const sourceLang = this.#languageMapper ? this.#languageMapper(job.sourceLang) : job.sourceLang;
        const targetLang = this.#languageMapper ? this.#languageMapper(job.targetLang) : job.targetLang;

        // flatten tus to xml format -- potentially allow for other formats
        const payload = tus.map(tu => {
            const [source, phMap ] = utils.flattenNormalizedSourceToXmlV1(tu.nsrc);
            const xmlTu = { guid: tu.guid, bundle: tu.rid, key: tu.sid };
            tu.notes?.desc && (xmlTu.notes = tu.notes.desc);
            xmlTu.source = source; // adding source second so that LLMs see notes first
            Object.keys(phMap).length > 0 && (xmlTu.phMap = phMap);
            return xmlTu;
        });

        // create task to merge translated chunks
        const requestTranslationsTask = opsManager.createTask(this.id, this.#opNames.mergeTranslatedChunksOp);

        // create chunks and associated ops as inputs to mergeTranslatedChunksOp
        let chunkNumber = 0;
        for (let currentIdx = 0; currentIdx < payload.length;) {
            const flattenedTus = [];
            let currentTotalLength = 0;
            while (currentIdx < payload.length && flattenedTus.length < this.maxChunkSize && payload[currentIdx].source.length + currentTotalLength < this.maxCharLength) {
                currentTotalLength += payload[currentIdx].source.length;
                flattenedTus.push(payload[currentIdx]);
                currentIdx++;
            }
            if (flattenedTus.length === 0) {
                throw new Error(`String at index ${currentIdx} exceeds ${this.maxCharLength} max char length`);
            }
            logInfo`Preparing chunked translation with ${flattenedTus.length} ${[flattenedTus.length, 'string', 'strings']}, total char length: ${currentTotalLength}`;
            const tuMeta = [];
            const xmlTus = flattenedTus.map(flattenedTu => {
                const { guid, phMap, ...xmlTu } = flattenedTu;
                tuMeta.push({ guid, phMap });
                return xmlTu;
            });
            chunkNumber++;
            const args = this.prepareTranslateChunkArgs({ sourceLang, targetLang, xmlTus, jobGuid: job.jobGuid, instructions: job.instructions, chunkNumber });
            requestTranslationsTask.rootOp.enqueue(this.#opNames.startTranslateChunkOp, { ...args, tuMeta });
        }
        requestTranslationsTask.rootOp.args = { jobResponse };
        return requestTranslationsTask;
    }

    prepareTranslateChunkArgs(chunkArgs) {
        return chunkArgs; // this is normally overridden by the provider
    }

    async startTranslateChunkOp(op) {
        const { tuMeta, ...args } = op.args;
        const raw = await this.startTranslateChunk(args);
        const flattenedRes = this.convertTranslationResponse(raw);
        if (tuMeta.length !== flattenedRes.length) {
            logError`Expected chunk to have ${tuMeta.length} translations but got ${flattenedRes.length}`;
            return { raw, res: [] }; // discard the chunk because we can't pair up the translations with the guids
        }
        const normalizedRes = tuMeta.map(({ guid, phMap }, idx) => {
            try {
                const { tgt, ...tu } = flattenedRes[idx];
                tu.guid = guid;
                tu.ntgt = utils.extractNormalizedPartsFromXmlV1(tgt, phMap || {});
                return tu;
            } catch (e) {
                logError`Error extracting normalized parts for tu ${guid}: ${e}`;
                return null;
            }
        });
        const res = normalizedRes.filter(Boolean); // remove tus that failed to be normalized
        return { raw, res }; // return raw just for debugging
    }

    /**
     * Provider-specific method to synchronously translate a chunk of tus.
     * @param {object} args - The provider-specific arguments generated by prepareTranslateChunkArgs.
     * @returns {Promise<*>} Any object containing the translation results.
     */
    async startTranslateChunk(args) {
        throw new Error(`startTranslateChunk not implemented in ${this.constructor.name}`);
    }

    /**
     * Convert the raw translation response into a standard format.
     * @param {Object} chunk - The raw response for the chunk.
     * @returns {Array} An array containing the translation results.
     */
    convertTranslationResponse(chunk) {
        throw new Error(`convertTranslationResponse not implemented in ${this.constructor.name}`);
    }

    async mergeTranslatedChunksOp(op) {
        const { jobResponse } = op.args;
        // TODO: find a better way to handle pending status
        // if (op.inputs.find(input => input === null)) {
            // logVerbose`ChunkedRemoteTranslationProvider submitted ${op.inputs.length} chunks with ${guids.length} guids`;
            // jobResponse.inflight = guids;
            // jobResponse.envelope = { chunkSizes, tuMeta };
            // jobResponse.status = 'pending';
        //     return jobResponse;
        // }
        const ts = L10nContext.regression ? 1 : new Date().getTime();
        const translations = op.inputs.filter(Boolean).map(input => input.res).flat(1);
        jobResponse.tus = translations.map(tu => ({ ...tu, ts, q: this.quality }));
        return jobResponse;
    }

    // async continue(job) {
        // throw new Error(`continue not implemented in ${this.constructor.name}`);
        // TODO: implement it by hydrating the old task and continuing the pending ops (that need to be added)
        // logVerbose`ChunkedRemoteTranslationProvider provider updating job ${job.jobGuid}`;
        // const { inflight, ...jobResponse } = await super.continue(job);
        // try {
        //     const requestTranslationsTask = opsManager.createTask(this.id, this.#opNames.mergeTranslatedChunksOp);
        //     job.envelope.chunkSizes.forEach(async (chunkSize, chunk) => {
        //         L10nContext.logger.info(`Enqueue chunk fetcher for job: ${job.jobGuid} chunk:${chunk} chunkSize:${chunkSize}`);
        //         requestTranslationsTask.rootOp.enqueue(this.#opNames.continueTranslateChunkOp, {
        //             jobGuid: job.jobGuid,
        //             chunk,
        //             chunkSize,
        //         });
        //     });
        //     requestTranslationsTask.rootOp.args = {
        //         guids: inflight,
        //         tuMeta: job.envelope.tuMeta,
        //         quality: this.quality,
        //         ts: L10nContext.regression ? 1 : new Date().getTime(),
        //         chunkSizes: job.envelope.chunkSizes,
        //     };
        //     const receivedTus = await requestTranslationsTask.execute();
        //     jobResponse.tus = receivedTus;
        //     jobResponse.taskName = L10nContext.regression ? 'x' : requestTranslationsTask.taskName;
        //     return jobResponse;
        // // eslint-disable-next-line no-unused-vars
        // } catch (error) {
        //     return job; // getting errors is expected, just leave the job pending
        // }
    // }

    /**
     * Fetches a translated chunk from the remote provider.
     * @param {object} op - The operation context containing fetch parameters.
     * @returns {Promise<*>} Any object containing the translation results.
     */
    async continueTranslateChunkOp(op) {
        throw new Error(`continueTranslateChunkOp not implemented in ${this.constructor.name}`);
    }

    async info() {
        const info = await super.info();
        info.description.push(styleString`Max chunk size: ${this.maxChunkSize.toLocaleString()}, max char length: ${this.maxCharLength.toLocaleString()}`);
        return info;
    }
}
