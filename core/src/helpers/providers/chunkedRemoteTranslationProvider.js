import { getRegressionMode, logVerbose, logInfo, styleString, logError } from '../../l10nContext.js';
import * as utils from '../utils.js';
import { BaseTranslationProvider } from './baseTranslationProvider.js';
import * as opsManager from '../../opsManager/index.js';

/**
 * @typedef {import('../../interfaces.js').Job} Job
 * @typedef {import('../../interfaces.js').TranslateChunkArgs} TranslateChunkArgs
 * @typedef {import('../../interfaces.js').ProviderTranslateChunkArgs} ProviderTranslateChunkArgs
 * @typedef {import('../../interfaces.js').ProviderResponseChunk} ProviderResponseChunk
 * @typedef {import('../../interfaces.js').TranslatedChunk} TranslatedChunk
 * @typedef {import('../../interfaces.js').ChunkTuMeta} ChunkTuMeta
 * @typedef {import('../../interfaces.js').TranslateChunkOpResult} TranslateChunkOpResult
 * @typedef {import('../../opsManager/task.js').default} Task
 * @typedef {import('../../opsManager/operation.js').default} Op
 */

const MAX_CHAR_LENGTH = 9900;
const MAX_CHUNK_SIZE = 125;

/**
 * @typedef {object} ChunkedRemoteTranslationProviderOptions
 * @property {string} [id] - Global identifier for the provider.
 * @property {Record<string, string[]>} [supportedPairs] - Supported language pairs for the provider.
 * @property {number} [costPerWord] - The estimated cost per word for the provider.
 * @property {number} [costPerMChar] - The estimated cost per million characters for the provider.
 * @property {number} quality - The quality score (e.g., 0-100) to assign to translations generated by this provider. This is required.
 * @property {number} [maxCharLength=9900] - Maximum total characters allowed in a single API request chunk. Defaults to 9900 if not provided.
 * @property {number} [maxChunkSize=125] - Maximum number of text segments (strings) allowed in a single API request chunk. Defaults to 125 if not provided.
 * @property {(languageCode: string) => string} [languageMapper] - An optional function to map standard language codes
 *   (e.g., 'en-US') to provider-specific codes if needed. Receives a standard language code and should return the
 *   provider-specific code. If omitted, language codes are used as-is.
 * @property {boolean} [includeTranslations=false] - When true and a previous translation (ntgt) exists on a TU, include it in the xmlTu as a 'translation' property.
 */

/**
 * Base class for providers that need to enforce chunking of input strings and asynchronous translation.
 * @class ChunkedRemoteTranslationProvider
 * @extends BaseTranslationProvider
 */
export class ChunkedRemoteTranslationProvider extends BaseTranslationProvider {

    #languageMapper;
    #opNames = {};

    /**
     * Initializes a new instance of the ChunkedRemoteTranslationProvider class.
     * @param {ChunkedRemoteTranslationProviderOptions} options - Configuration options for the provider.
     */
    constructor({ maxCharLength, maxChunkSize, languageMapper, includeTranslations, ...options }) {
        if (options.quality === undefined) {
            throw new Error('You must specify quality for ChunkedRemoteTranslationProvider');
        }
        super(options);
        this.maxCharLength = maxCharLength ?? MAX_CHAR_LENGTH;
        this.maxChunkSize = maxChunkSize ?? MAX_CHUNK_SIZE;
        this.#languageMapper = languageMapper;
        this.includeTranslations = includeTranslations ?? false;
        this.#opNames.startTranslateChunkOp = `${this.id}.startTranslateChunkOp`;
        this.#opNames.mergeTranslatedChunksOp = `${this.id}.mergeTranslatedChunksOp`;
        this.#opNames.continueTranslateChunkOp = `${this.id}.continueTranslateChunkOp`;
        opsManager.registerOp(this.startTranslateChunkOp.bind(this), { opName: this.#opNames.startTranslateChunkOp, idempotent: false });
        opsManager.registerOp(this.mergeTranslatedChunksOp.bind(this), { opName: this.#opNames.mergeTranslatedChunksOp, idempotent: true });
        opsManager.registerOp(this.continueTranslateChunkOp.bind(this), { opName: this.#opNames.continueTranslateChunkOp, idempotent: true });
    }

    /**
     * Creates a task for chunked translation.
     * @param {Job} job - The job to create a task for.
     * @returns {Task} The task to execute.
     */
    createTask(job) {
        logVerbose`ChunkedRemoteTranslationProvider creating task for job ${job.jobGuid}`;
        const { tus, ...jobResponse } = job;
        const sourceLang = this.#languageMapper ? this.#languageMapper(job.sourceLang) : job.sourceLang;
        const targetLang = this.#languageMapper ? this.#languageMapper(job.targetLang) : job.targetLang;

        // flatten tus to xml format -- potentially allow for other formats
        const payload = tus.map(tu => {
            const [source, phMap ] = utils.flattenNormalizedSourceToXmlV1(tu.nsrc);
            const xmlTu = { guid: tu.guid, bundle: tu.rid, key: tu.sid };
            (typeof tu.notes !== 'string' && tu.notes?.desc) && (xmlTu.notes = tu.notes.desc);
            xmlTu.source = source; // adding source second so that LLMs see notes first
            Object.keys(phMap).length > 0 && (xmlTu.phMap = phMap);
            if (this.includeTranslations && tu.ntgt) {
                xmlTu.translation = utils.flattenNormalizedSourceToXmlV1(tu.ntgt)[0];
            }
            return xmlTu;
        });

        // create task to merge translated chunks
        const requestTranslationsTask = opsManager.createTask(this.id, this.#opNames.mergeTranslatedChunksOp);

        // create chunks and associated ops as inputs to mergeTranslatedChunksOp
        let chunkNumber = 0;
        for (let currentIdx = 0; currentIdx < payload.length;) {
            const flattenedTus = [];
            let currentTotalLength = 0;
            while (currentIdx < payload.length && flattenedTus.length < this.maxChunkSize && payload[currentIdx].source.length + currentTotalLength < this.maxCharLength) {
                currentTotalLength += payload[currentIdx].source.length;
                flattenedTus.push(payload[currentIdx]);
                currentIdx++;
            }
            if (flattenedTus.length === 0) {
                throw new Error(`String at index ${currentIdx} exceeds ${this.maxCharLength} max char length`);
            }
            logInfo`Preparing chunked translation with ${flattenedTus.length} ${[flattenedTus.length, 'string', 'strings']}, total char length: ${currentTotalLength}`;

            /** @type {ChunkTuMeta[]} */
            const tuMeta = [];

            /** @type {import('../../interfaces.js').XmlTu[]} */
            const xmlTus = flattenedTus.map(flattenedTu => {
                const { guid, phMap, ...xmlTu } = flattenedTu;
                tuMeta.push({ guid, phMap });
                return /** @type {import('../../interfaces.js').XmlTu} */ (xmlTu);
            });
            chunkNumber++;
            const args = this.prepareTranslateChunkArgs({ sourceLang, targetLang, xmlTus, jobGuid: job.jobGuid, instructions: job.instructions, chunkNumber });
            requestTranslationsTask.rootOp.enqueue(this.#opNames.startTranslateChunkOp, { ...args, tuMeta });
        }
        requestTranslationsTask.rootOp.args = { jobResponse };
        return requestTranslationsTask;
    }

    /**
     * Prepares chunk arguments for translation. Override to add provider-specific properties.
     * @param {TranslateChunkArgs} chunkArgs - Base chunk arguments.
     * @returns {ProviderTranslateChunkArgs} Provider-specific chunk arguments.
     */
    prepareTranslateChunkArgs(chunkArgs) {
        return chunkArgs; // this is normally overridden by the provider
    }

    /**
     * Operation handler for translating a single chunk.
     * @param {Op} op - The operation with args containing tuMeta and provider-specific args.
     * @returns {Promise<TranslateChunkOpResult>} Result with raw response and normalized translations.
     */
    async startTranslateChunkOp(op) {
        const opArgs = /** @type {ProviderTranslateChunkArgs & { tuMeta: ChunkTuMeta[] }} */ (/** @type {unknown} */ (op.args));
        const { tuMeta, ...args } = opArgs;
        const raw = await this.startTranslateChunk(args);
        const flattenedRes = this.convertTranslationResponse(raw);
        if (tuMeta.length !== flattenedRes.length) {
            logError`Expected chunk to have ${tuMeta.length} translations but got ${flattenedRes.length}`;
            return { raw, res: [] }; // discard the chunk because we can't pair up the translations with the guids
        }
        const normalizedRes = tuMeta.map(({ guid, phMap }, idx) => {
            try {
                const { tgt, ...tu } = flattenedRes[idx];
                return {
                    ...tu,
                    guid,
                    ntgt: utils.extractNormalizedPartsFromXmlV1(tgt, phMap || {}),
                };
            } catch (e) {
                logError`Error extracting normalized parts for tu ${guid}: ${e}`;
                return null;
            }
        });

        /** @type {Array<{ guid: string; ntgt: import('../../interfaces.js').NormalizedString; cost?: number }>} */
        const res = normalizedRes.filter(/** @returns {x is { guid: string; ntgt: import('../../interfaces.js').NormalizedString; cost?: number }} */ (x) => x !== null);
        return { raw, res }; // return raw just for debugging
    }

    /**
     * Provider-specific method to translate a chunk of TUs.
     * Must be implemented by subclasses.
     * @param {ProviderTranslateChunkArgs} args - Provider-specific arguments from prepareTranslateChunkArgs.
     * @returns {Promise<ProviderResponseChunk>} Raw response from the translation API.
     */
    // eslint-disable-next-line no-unused-vars
    async startTranslateChunk(args) {
        throw new Error(`startTranslateChunk not implemented in ${this.constructor.name}`);
    }

    /**
     * Converts the raw translation response into a standard format.
     * Must be implemented by subclasses.
     * @param {ProviderResponseChunk} chunk - The raw response from startTranslateChunk.
     * @returns {TranslatedChunk[]} Array of normalized translation results.
     */
    // eslint-disable-next-line no-unused-vars
    convertTranslationResponse(chunk) {
        throw new Error(`convertTranslationResponse not implemented in ${this.constructor.name}`);
    }

    /**
     * Operation handler that merges translated chunks into the final job response.
     * @param {Op} op - The operation with inputs from all chunk translations.
     * @returns {Promise<Job>} The completed job with merged translations.
     */
    async mergeTranslatedChunksOp(op) {
        const opArgs = /** @type {{ jobResponse: Job }} */ (op.args);
        const { jobResponse } = opArgs;
        // TODO: find a better way to handle pending status
        // if (op.inputs.find(input => input === null)) {
            // logVerbose`ChunkedRemoteTranslationProvider submitted ${op.inputs.length} chunks with ${guids.length} guids`;
            // jobResponse.inflight = guids;
            // jobResponse.envelope = { chunkSizes, tuMeta };
            // jobResponse.status = 'pending';
        //     return jobResponse;
        // }
        const ts = getRegressionMode() ? 1 : new Date().getTime();
        const inputs = /** @type {TranslateChunkOpResult[]} */ (op.inputs.filter(Boolean));
        const translations = inputs.map(input => input.res).flat(1);
        jobResponse.tus = translations.map(tu => ({ ...tu, ts, q: this.quality }));
        return jobResponse;
    }

    // async continue(job) {
        // throw new Error(`continue not implemented in ${this.constructor.name}`);
        // TODO: implement it by hydrating the old task and continuing the pending ops (that need to be added)
        // logVerbose`ChunkedRemoteTranslationProvider provider updating job ${job.jobGuid}`;
        // const { inflight, ...jobResponse } = await super.continue(job);
        // try {
        //     const requestTranslationsTask = opsManager.createTask(this.id, this.#opNames.mergeTranslatedChunksOp);
        //     job.envelope.chunkSizes.forEach(async (chunkSize, chunk) => {
        //         L10nContext.logger.info(`Enqueue chunk fetcher for job: ${job.jobGuid} chunk:${chunk} chunkSize:${chunkSize}`);
        //         requestTranslationsTask.rootOp.enqueue(this.#opNames.continueTranslateChunkOp, {
        //             jobGuid: job.jobGuid,
        //             chunk,
        //             chunkSize,
        //         });
        //     });
        //     requestTranslationsTask.rootOp.args = {
        //         guids: inflight,
        //         tuMeta: job.envelope.tuMeta,
        //         quality: this.quality,
        //         ts: L10nContext.regression ? 1 : new Date().getTime(),
        //         chunkSizes: job.envelope.chunkSizes,
        //     };
        //     const receivedTus = await requestTranslationsTask.execute();
        //     jobResponse.tus = receivedTus;
        //     jobResponse.taskName = L10nContext.regression ? 'x' : requestTranslationsTask.taskName;
        //     return jobResponse;
        // // eslint-disable-next-line no-unused-vars
        // } catch (error) {
        //     return job; // getting errors is expected, just leave the job pending
        // }
    // }

    /**
     * Operation handler for continuing/fetching a pending chunk translation.
     * Override in subclasses that support async continuation.
     * @param {Op} op - The operation context containing fetch parameters.
     * @returns {Promise<TranslateChunkOpResult>} Result with raw response and normalized translations.
     */
    // eslint-disable-next-line no-unused-vars
    async continueTranslateChunkOp(op) {
        throw new Error(`continueTranslateChunkOp not implemented in ${this.constructor.name}`);
    }

    async info() {
        const info = await super.info();
        info.description.push(styleString`Max chunk size: ${this.maxChunkSize.toLocaleString()}, max char length: ${this.maxCharLength.toLocaleString()}`);
        this.includeTranslations && info.description.push(styleString`Include previous translations: enabled`);
        return info;
    }
}
